{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":0},{"_id":"themes/yilia/source/main.0cf68a.css","path":"main.0cf68a.css","modified":1,"renderable":1},{"_id":"themes/yilia/source/slider.e37972.js","path":"slider.e37972.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/mobile.992cbe.js","path":"mobile.992cbe.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/main.0cf68a.js","path":"main.0cf68a.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"9a916c3112e989d75dd0c0fe81fa21592714717c","modified":1526295220709},{"_id":"source/_posts/hello-world-1.md","hash":"eb927e490de576af90fe186aa40dea3bed2bba58","modified":1526295220710},{"_id":"source/_posts/hello-world.md","hash":"a3cb8e1f98b8ff19e996a08a99e0b275475cb4e4","modified":1526295220710},{"_id":"source/_posts/react基础.md","hash":"acafdc4383028a9fc85658dccd54ff482ffeac71","modified":1526295220711},{"_id":"source/_posts/react基础2.md","hash":"7c9e6091fbb12e33154e58206c5e4f13499f8658","modified":1526295220712},{"_id":"source/categories/index.md","hash":"7aeb373674de4a81907d8e2a08f9a8f6cb50ce65","modified":1526295220714},{"_id":"source/about/index.md","hash":"013e42385e5c332011f0218b9a4d71b54acc3d60","modified":1526295220713},{"_id":"source/images/avatar.jpg","hash":"1163c8cdc6377a21641c89bc547515223697466f","modified":1526295220715},{"_id":"source/photos/index.md","hash":"c1768b05ae849934a767b94533d15818324a9249","modified":1526295220717},{"_id":"source/tags/index.md","hash":"2355e5c04c2d06b8cac48ee139a084a244049c08","modified":1526295220718},{"_id":"themes/yilia/.babelrc","hash":"db600d40e93e6d8023737a65d58d3be7370e5e30","modified":1526556020136},{"_id":"themes/yilia/.editorconfig","hash":"daaa8757fac18f8735fadd0a37a42c06f421ca14","modified":1526556020137},{"_id":"themes/yilia/.eslintignore","hash":"ed9d8911ca08c3dd5072c48dd0be4d06f8897730","modified":1526556020138},{"_id":"themes/yilia/.eslintrc.js","hash":"303d25adf02ad65720e537a16a4a137d14bb755f","modified":1526556020139},{"_id":"themes/yilia/.gitattributes","hash":"758cfbecfa7919e99abddf3297f37cde7e3d8d4e","modified":1526556020140},{"_id":"themes/yilia/.gitignore","hash":"00dfdd5e482155434664f9eab001cdaa91f2c98c","modified":1526556020140},{"_id":"themes/yilia/README.md","hash":"1bf755806af9d8874bd22e1abbdaaa24328ef4dc","modified":1526556020140},{"_id":"themes/yilia/_config.yml","hash":"07bfca36c7672bed7a189ada56275b4eaf4a7583","modified":1526556020141},{"_id":"themes/yilia/package.json","hash":"ee6aa61f1cb89fd549e3e087c0232207a9c9ee30","modified":1526556020175},{"_id":"themes/yilia/webpack.config.js","hash":"da7657347109ddb4ab8602b219778117254677fe","modified":1526556020236},{"_id":"themes/yilia/languages/default.yml","hash":"f26a34a7983d4bc17c65c7f0f14da598e62ce66d","modified":1526556020142},{"_id":"themes/yilia/languages/fr.yml","hash":"b4be1c1592a72012e48df2b3ec41cc9685573e50","modified":1526556020142},{"_id":"themes/yilia/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1526556020143},{"_id":"themes/yilia/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1526556020143},{"_id":"themes/yilia/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1526556020144},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"b057f389c6713010f97d461e48ec959b0b6f3b44","modified":1526556020144},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1526556020145},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1526556020170},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1526556020172},{"_id":"themes/yilia/layout/layout.ejs","hash":"b471ab706d48e0be3f783eab1c94bf5878ef5a94","modified":1526556020173},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1526556020173},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1526556020174},{"_id":"themes/yilia/layout/index.ejs","hash":"ec498c6c0606acde997ce195dad97b267418d980","modified":1526556020172},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1526556020175},{"_id":"themes/yilia/source/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1526556020232},{"_id":"themes/yilia/source/slider.e37972.js","hash":"ce5eac88301fe4f2fce0fb6203adfd58eb8313ac","modified":1526556020235},{"_id":"themes/yilia/source-src/css.ejs","hash":"cf7eab48d626433120d1ef9697f719a359817018","modified":1526556020176},{"_id":"themes/yilia/source-src/script.ejs","hash":"28abac2426761d7e715b38aadd86ce6549c8ae77","modified":1526556020224},{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1526556020168},{"_id":"themes/yilia/source/mobile.992cbe.js","hash":"1801ef448909ea23c0a48e9d63b80d0cfd5534ce","modified":1526556020234},{"_id":"themes/yilia/source/main.0cf68a.js","hash":"283ae27ea37ac3e0e45b2e05c2482a4c594b9c25","modified":1526556020233},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"c70f367f54064a441e574c913f5e0ea121d0f899","modified":1526556020146},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"edc0154b30a4127acda10297bec6aacf754b4ac4","modified":1526556020146},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a4eacc2bc1278095a0ef99f904b0634c78f980eb","modified":1526556020147},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"8dea8f5f93a60185439b330b0f1d1649a6ab4bd0","modified":1526556020147},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"751e5deab5365348be5243688b419c82d337ab9a","modified":1526556020148},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"155327c23607f69989b58845f24d842a54e504b8","modified":1526556020149},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"236f8a377b2e4e35754319c3029bcd4a4115431d","modified":1526556020149},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"871f81cacd5d41cb2eb001cd56254217a857dc2f","modified":1526556020149},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1526556020150},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"12ca7d8dba56bc767b9309dda9526dcbaffc1614","modified":1526556020150},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"b69855e07b65117769adc515cb64b803932068c9","modified":1526556020159},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"fb1b8457b9eb15b55da1bf7b133e12c375dd26f8","modified":1526556020159},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"11550a418921d330e6553be0569a94ab5a217967","modified":1526556020160},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"ccec1fc70f021cb50ac85b524e7949878ab93a18","modified":1526556020161},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"0ffcb251b79e8a920c9b4cb6bb7a96a808816165","modified":1526556020169},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"cc1c39903aed0a0601d104238d2bbd13ad2a36f3","modified":1526556020169},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1526556020226},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1526556020226},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"75767c904d483d9b93469afb6b92bb6bdface639","modified":1526556020227},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1526556020228},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1526556020229},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1526556020229},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1526556020230},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1526556020231},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1526556020231},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"29ba600e98ed55f7af4ade8038272c84cba21188","modified":1526556020177},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"ce227b6f5a9af194fd5d455200630f32c05e151f","modified":1526556020178},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"d6a7dd88404b383b5b94e4c7ec675a410c41f3cc","modified":1526556020179},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"f7388f5c11370ef462f7cb913d8f72edf24ecaf9","modified":1526556020180},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"1577a2336b3ad122f49f60dff2bc1a97d4e7b18b","modified":1526556020180},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"8f82fe898ba1c1bd00c24a7d8270feddc7eba3bc","modified":1526556020181},{"_id":"themes/yilia/source-src/css/article.scss","hash":"55d082fec4c6bb341725567acaa29ce37d50320a","modified":1526556020182},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"07244c188f58ecfb90bb7c047b8cde977f1dc4b4","modified":1526556020182},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"b85f344f2c66d43d7094746e0a9ccb21d0534201","modified":1526556020183},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"96d7eb1d42c06fdcccb8ef969f6ecd30c3194903","modified":1526556020188},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7ca837a4cc34db1c35f01baec85eb10ccc64ea86","modified":1526556020193},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1526556020193},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"f53ea8270752b5919ec5d79224d22af91f2eda12","modified":1526556020194},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"40e5aa5056dc0b3b9f51c5b387370b612e265d4e","modified":1526556020194},{"_id":"themes/yilia/source-src/css/left.scss","hash":"80dac621e43581a254d0152d5df901e4d0b01c09","modified":1526556020196},{"_id":"themes/yilia/source-src/css/main.scss","hash":"9eba1fcf4805256697528fcf3b767cf6dd8d0591","modified":1526556020197},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"19f10fd2f0c3377aa4b165b3c2291ecf86dd9351","modified":1526556020197},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"d995dcd483a250fe61b426158afb61bf8923a927","modified":1526556020198},{"_id":"themes/yilia/source-src/css/page.scss","hash":"244c4d75c375978ff9edb74acc68825e63c6b235","modified":1526556020198},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"a557a9ed244c82b8b71e9da9de3339d92783499f","modified":1526556020199},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"2495f7e4e3b055735c531f944b5f40a118a351ec","modified":1526556020199},{"_id":"themes/yilia/source-src/css/share.scss","hash":"9d6f6884f40c191882e56a1e1e1192400944a515","modified":1526556020200},{"_id":"themes/yilia/source-src/css/social.scss","hash":"a10a038a1dac8953cb4ffc7e04272eff9fac54e4","modified":1526556020211},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"399744e98e7c67939ed9b23c2670d8baad044eda","modified":1526556020212},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"915c93edd67c5326695cc7dc84b14c5f154dbcc8","modified":1526556020212},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"2924fb6f77c4a9973cd928c2c7db0acb848ed483","modified":1526556020213},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"b81cedbe31accca82e597801186911a7b5e6841c","modified":1526556020214},{"_id":"themes/yilia/source-src/js/Q.js","hash":"e56d9710afa79b31ca6b9fbd845f6d1895f5214b","modified":1526556020215},{"_id":"themes/yilia/source-src/js/anm.js","hash":"d18f6276a352b871390a4112d479b9e58b8cdbbe","modified":1526556020216},{"_id":"themes/yilia/source-src/js/aside.js","hash":"5e4c3c3d61f1e1ce2f09688d3aff25fadc851fff","modified":1526556020217},{"_id":"themes/yilia/source-src/js/browser.js","hash":"4dc04845cf27f350922b63f1813a9c82e6e33b05","modified":1526556020217},{"_id":"themes/yilia/source-src/js/fix.js","hash":"67b8819abb886c9d066fb3b0624ca15e06f63fe0","modified":1526556020218},{"_id":"themes/yilia/source-src/js/main.js","hash":"fe98bf90ce61658fe16ae057f8b6a512a845af3b","modified":1526556020218},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"461c08ffcbc724d74ec7e0ff38e171eefe0f89fd","modified":1526556020219},{"_id":"themes/yilia/source-src/js/report.js","hash":"57680f9a23bd0a1eaafd64ae08cc33e20627ab15","modified":1526556020219},{"_id":"themes/yilia/source-src/js/share.js","hash":"d4ccff8266c37363b3904226f5d035b7db882c61","modified":1526556020221},{"_id":"themes/yilia/source-src/js/slider.js","hash":"0beaa112657ad57c723d9e773d5b79de60c1dd74","modified":1526556020222},{"_id":"themes/yilia/source-src/js/util.js","hash":"3bcdeb95072b85600874424e6929e3e22cfddaa0","modified":1526556020223},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"c699cf3c89409ec8f044258e0715a470861b5d5d","modified":1526556020223},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"e98ec0b3b56f14d1d79af99ceb42727719a584f3","modified":1526556020168},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"e777cbf959b11c4dfda649c562799899b90ab4a3","modified":1526556020161},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"086c8a88fd3bcae7ec13258df58e25d6354af2fa","modified":1526556020162},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"aae96de18d48cd3b9b7bf6fed0100e15b53cca97","modified":1526556020162},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"f6b4c4eaafb5ac386273354b5f64a26139b7a3b0","modified":1526556020163},{"_id":"themes/yilia/layout/_partial/post/gitment.ejs","hash":"25655016773aa5d0774c56115ae1736a9fc9ea1f","modified":1526556020163},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"b6a97043f9ec37e571aacacfedcda1d4d75e3c7c","modified":1526556020164},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"345b262e3c3b75c0cd9a93d9ecabcf06e33e54ff","modified":1526556020165},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2c4e4ca36c9bb4318506c38aca7127f1f44d827f","modified":1526556020166},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1526556020166},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"fb022502c741b4a26bad6b2ad37245c10ede3f1a","modified":1526556020166},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"1834c3ed8560716e63bb3a50be94cac87fbbeaf3","modified":1526556020184},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"262ffcd88775080b7f511db37f58d2bcb1b2bfc7","modified":1526556020185},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"91db061c9c17628291a005e5bd4936cf9d35a6c4","modified":1526556020185},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"398a49913b4a47d928103562b1ce94520be4026a","modified":1526556020187},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"6e75bdaa46de83094ba0873099c6e7d656a22453","modified":1526556020188},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1526556020190},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"75767c904d483d9b93469afb6b92bb6bdface639","modified":1526556020191},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1526556020192},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1526556020192},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1526556020195},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1526556020195},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1526556020196}],"Category":[],"Data":[],"Page":[{"title":"about","date":"2018-05-09T09:02:05.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2018-05-09 17:02:05\n---\n","updated":"2018-05-14T10:53:40.713Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjhag1ytc0001i0v6xd4d6ii1","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2018-05-09T09:00:40.000Z","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-05-09 17:00:40\nlayout: categories\n---\n","updated":"2018-05-14T10:53:40.714Z","path":"categories/index.html","comments":1,"_id":"cjhag1ytg0003i0v62m0mtkm1","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"photos","date":"2018-05-09T09:27:51.000Z","_content":"","source":"photos/index.md","raw":"---\ntitle: photos\ndate: 2018-05-09 17:27:51\n---\n","updated":"2018-05-14T10:53:40.717Z","path":"photos/index.html","comments":1,"layout":"page","_id":"cjhag1yu0000ei0v68ptzg9nn","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","layout":"tags","date":"2018-05-09T09:01:25.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\nlayout: tags\ndate: 2018-05-09 17:01:25\n---\n","updated":"2018-05-14T10:53:40.718Z","path":"tags/index.html","comments":1,"_id":"cjhag1yu1000fi0v6nbjjvr5q","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"hello,world","date":"2018-05-09T07:30:13.000Z","_content":"\n#### 今天是个好日子\n","source":"_posts/hello-world-1.md","raw":"---\ntitle: 'hello,world'\ndate: 2018-05-09 15:30:13\ntags: 哈哈哈1223\n---\n\n#### 今天是个好日子\n","slug":"hello-world-1","published":1,"updated":"2018-05-14T10:53:40.710Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjhag1ysu0000i0v67r6wvaud","content":"<h4 id=\"今天是个好日子\"><a href=\"#今天是个好日子\" class=\"headerlink\" title=\"今天是个好日子\"></a>今天是个好日子</h4>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"今天是个好日子\"><a href=\"#今天是个好日子\" class=\"headerlink\" title=\"今天是个好日子\"></a>今天是个好日子</h4>"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n\n\n---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n<!-- more -->\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n\n---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ntags: 哈哈哈1223\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n\n\n---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n<!-- more -->\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n\n---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2018-05-14T10:53:40.710Z","updated":"2018-05-14T10:53:40.710Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjhag1yte0002i0v6wl1yanx3","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n<hr>\n<h2 id=\"title-Hello-World\"><a href=\"#title-Hello-World\" class=\"headerlink\" title=\"title: Hello World\"></a>title: Hello World</h2><p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start-1\"><a href=\"#Quick-Start-1\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post-1\"><a href=\"#Create-a-new-post-1\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<a id=\"more\"></a>\n<h3 id=\"Run-server-1\"><a href=\"#Run-server-1\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files-1\"><a href=\"#Generate-static-files-1\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites-1\"><a href=\"#Deploy-to-remote-sites-1\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n<hr>\n<h2 id=\"title-Hello-World-1\"><a href=\"#title-Hello-World-1\" class=\"headerlink\" title=\"title: Hello World\"></a>title: Hello World</h2><p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start-2\"><a href=\"#Quick-Start-2\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post-2\"><a href=\"#Create-a-new-post-2\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server-2\"><a href=\"#Run-server-2\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files-2\"><a href=\"#Generate-static-files-2\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites-2\"><a href=\"#Deploy-to-remote-sites-2\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n<hr>\n<h2 id=\"title-Hello-World\"><a href=\"#title-Hello-World\" class=\"headerlink\" title=\"title: Hello World\"></a>title: Hello World</h2><p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start-1\"><a href=\"#Quick-Start-1\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post-1\"><a href=\"#Create-a-new-post-1\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>","more":"<h3 id=\"Run-server-1\"><a href=\"#Run-server-1\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files-1\"><a href=\"#Generate-static-files-1\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites-1\"><a href=\"#Deploy-to-remote-sites-1\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n<hr>\n<h2 id=\"title-Hello-World-1\"><a href=\"#title-Hello-World-1\" class=\"headerlink\" title=\"title: Hello World\"></a>title: Hello World</h2><p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start-2\"><a href=\"#Quick-Start-2\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post-2\"><a href=\"#Create-a-new-post-2\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server-2\"><a href=\"#Run-server-2\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files-2\"><a href=\"#Generate-static-files-2\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites-2\"><a href=\"#Deploy-to-remote-sites-2\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>"},{"title":"'react基础2'","date":"2018-05-09T09:49:24.000Z","_content":"\n\n[react官网](https://reactjs.org/docs/hello-world.html)\n\n## 组件\n#### 1. 无状态组件\n  - 在React中，组件的名字必须用大写字母开头，而包含该组件定义的文件名也应该是大写字母(便于区分，也可以不是)。\n  - 无状态组件是纯展示组件，仅仅只是用于数据的展示，只根据传入的props来进行展示，不涉及到state状态处理，通过函数式的方式来创建一个无状态函数式组件(大多数组件都是无状态组件，通过简单的组合可以构建成其他的组件，最后合并成一个大的应用)。\n  - 无状态函数式组件是一个只带有render方法的组件，通过函数形式或者箭头函数形式创建，该组件无state状态。\n\n```\nimport React from \"react\";\n\n//创建方式一,相当于es5的函数声明的方式创建\n function NoState (props) {\n     return (\n         <div>this is NoState Component</div>\n     )\n }\n```\n\n```\n//创建方式二,相当于es5的函数表达式的方式创建\nconst NoState = (props) => {\n    return (\n        <div>this is Nostate Component</div>\n    )\n}\n\nexport default NoState\n```\n--------------------------------------------------------------------------------\n- 无状态函数式组件没有组件实例化的过程，成为一个render方法的函数来执行，减少分配的内存，使整体渲染性能得到提高，因此展示数据的组件优先选择这种方式。\n- 无状态组件没有实例化得过程，因此无法访问组件this中的对象\n- 无状态组件不需要组件生命周期管理和状态管理，底层在实现这种形式的组件的时候不会实现组件的生命周期方法，所以无状态组件不能参与组件生命周期管理\n- 无状态组件只能访问传入的props，同样的props会得到同样的渲染结果\n\n<!-- more -->\n\n当我们的组件开始有逻辑处理，之前的那种方式胜任不了时索要采取的一种形式，通过继承react的Component对象而来\n代码的render方法，则是Component中，专门提供的用来处理jsx模板的方法。\n第一种方式不同的是，我们接收传入进来的参数，使用的是this.props，第一种方式将props放置于函数参数中，而这种方式则是将props挂载与实例对象上，因此会有所不同\n```\n// helloWorld.jsx\nimport React, {Component} from 'react';\nclass HelloWorld extends Component {\n    clickHander = () => {\n        console.log(this.props);\n        console.log(this.props.name);\n    }\n\n    render() {\n        return (\n            <div onClick={this.clickHander}>{ this.props.name } say: Hello World!</div>\n        )\n    }\n}\nexport default HelloWorld;\n```\n\n## 组件之间的交互\n#### 父组件与子组件之间的交互\n1. 父组件修改子组件，只需要修改传入的props属性\n2. 子组件修改父组件，需要父组件向子组件传递一个函数，该函数在父组件中定义，在子组件中触发执行\n子组件与子组件之间的交互\n3. 通过影响共同的父组件来进行交互\n\n\n\n```\nstate = {\n    switch: 0,\n    name: this.props.name1\n}\nclickHander = () => {\n    const {name1, name2} = this.props;\n    if (this.state.switch === 0) {\n        this.setState({\n            switch: 1,\n            name: name2\n        })\n    } else {\n        this.setState({\n            switch: 0,\n            name: name1\n        })\n    }\n};\nrender() {\n    return (\n        <div onClick={this.clickHander}>hello world !{this.state.name}</div>\n    )\n}\n```\n\n先来说说state相关的基础知识。首先了解ES6 class语法的同学都应该知道，当我们通过这种方式来写的时候，其实是将state写入了构造函数之中。\n\nstate = {} // 等同于ES5构造函数中的this.state = {}\n在对象中，我们可以通过this.state的方式来访问state中所存储的属性\nsetState接收一个对象，它的运行结果类似于执行一次assign方法。会修改传入的属性，而其他的属性则保持不变\nreact赋予state的特性，则是当state被修改时，会引起组件的一次重新渲染。即render方法会重新执行一次。也正是由于这个特性，因此当我们想要改变界面上的元素内容时，常常只需要改变state中的值就行了\n而setState也有一个非常重要的特性，那就是，该方法是异步的。它并不会立即执行，而会在下一轮事件循环中执行\n// 假设state.name的初始值为Tom，我们改变它的值this.setState({    name: 'Jason'})// 然后立即查看它的值console.log(this.state.name) // 仍然为Tom，不会立即改变\n\n### refs\nreact组件其实是虚拟DOM，因此通常我们需要通过特殊的方式才能拿到真正的DOM元素。大概说一说虚拟DOM是个什么形式存在的，它其实就是通过js对象的方式将DOM元素相关的都存储其实，比如一个div元素可能会是这样\n```\n// 当然可能命名会是其他的，大概表达一个意思，不深究哈\n{\n    nodeName: 'div',\n    className: 'hello-world',\n    style: {},\n    parentNodes: 'root',\n    childrenNodes: []\n    ...\n}\n```\n\n而我们想要拿到真实的DOM元素，react中提供了一种叫做ref的属性来实现这个目的\n```\nimport React, { Component } from 'react';\nclass HelloWorld extends Component {\n    clickHander = () => {\n        console.log(this.refs)\n    } \n    render () {\n        return (\n            <div className=\"container\" onClick={this.clickHander}>\n                <div ref=\"hello\" className=\"hello\">Hello</div>\n                <div ref=\"world\" className=\"world\">World</div>\n            </div>\n        )\n    }\n}\nexport default HelloWorld;\n```\n为了区分ES6语法中的class关键字，当我们在jsx中给元素添加class时，需要使用className来代替\n我们在jsx中，可以给元素添加ref属性，而这些拥有ref属性的元素，会统一放在组件对象的refs中，因此，当我们想要访问对应的真实DOM时，则通过this.refs来访问即可。\n当然，ref的值不仅仅可以为一个名字，同时还可以为一个回调函数，这个函数会在render渲染时执行，也就是说，每当render函数执行一次，ref的回调函数也会执行一次。\n```\n// src/helloWorld.jsx\nimport React, { Component } from 'react';class HelloWorld extends Component {\n    clickHander = () => {\n        console.log(this.refs)\n    } refCallback = (elem) => {\n        console.log(elem);\n    } render () {\n        return (\n            <div className=\"container\" onClick={this.clickHander}>\n                <div ref=\"hello\" className=\"hello\">Hello</div>\n                <div ref={this.refCallback} className=\"world\">World</div>\n            </div>\n        )\n    }\n}export default HelloWorld;\n```\n\n\n### 组件生命周期\n件的生命周期，指的就是一个组件，从创建到销毁的这样一个过程，react为组件的生命周期提供了很多的钩子函数\n\n##### react组件有三种状态：\n- Mounted：已经插入真实DOM\n- Updating：正在被重新渲染\n- Unmounted：已移出真实DOM\n- \n##### 每个状态的处理函数\n- will：函数在进入状态之前调用\n- did：函数在进入状态之后调用\n\n##### 组件第一次渲染完成的前后时刻，所谓的渲染完成，即组件已经被渲染成为真实DOM并插入到了html之中\n  - componentWillMount 在首次渲染完成之前，此时可修改组件的state\n  - componentDidMount 真实DOM渲染完成之后，该方法可通过this.getDOMNode()访问到真实的DOM元素，可以使用其他的类库来操作这个DOM\n\n##### 组件属性(我们前面提到的props与state)更新的前后时刻\n  - componentWillUpdate 接收到一个新的state或者props时，在重新render之前调用，此时不允许更新props和state\n  - componentDidUpdate 组件完成更新之后调用，此时可访问新的DOM元素\n\n###### 组件取消挂载之前(取消之后就没必要提供钩子函数了)\n`componentWillUnmount`\n\n###### 两个特殊的处理函数\n  - `componentWillReceiveProps(object nextProps)`：组件接收到新的props时，在重新render之前调用,此时可以更改props和state。首先props发生改变->然后componentWillReceiveProps去判断是否需要重新渲染(`shouldComponentUpdate`)->如果不需要则继续running->如果需要则执行`componentWillUpdate`->渲染DOM树之后执行`componentDidUpdate`->进入running\n  - `shouldComponentUpdate(nextProps, nextState)`(更新发生前立即被调用) 接收到一个新的state或者props时，在重新render之前调用，组件判断是否重新render前调用。首先state发生改变->判断是否需要重新渲染新的props和state(`shouldComponentUpdate`) -> 根据判断决定执行render过程还是继续·保持running状态\n\n###### 三个统一调用的方法,用于组件初始化，获取默认属性和状态\n  - getDefaultProps：作用于组件类，只调用一次，返回对象用于设置默认的props，对于引用值，会在实例中共享\n  - getInitialState：作用于组件的实例，在实例创建时只调用一次，，用于初始化没个实例的state，可访问this.props\n  - render：必选的方法，创建vistual DOM （1. 只能通过this.props和this.state访问数据 2. 可以返回null、false或任何React组件 3. 只能出现一个顶级组件（不能返回数组）4.不能改变组件的状态 5. 不能修改DOM的输出\n\n###### 已挂载的方法\n  - component.forceUpdate() 可以在任何已经挂载的组件上使用，当你知道某些深处的组件状态未通过this.setState而改变了的时候\n\n\n\n>componentDidMount，组件第一次渲染完成之后调用的componentDidMount，既然是组件第一次渲染完成之后才会调用，也就是说，该函数在react组件的生命周期中，只会调用一次。而渲染完成，则表示组件已经被渲染成为真实DOM插入了html中。所以这时候就可以通过ref获取真实元素。在实际开发中，常常需要通过ajax获取数据，而数据请求的这个行为，则最适合放在componentDidMount中来执行。通常会在首次渲染改变组件状态(state)的行为，或者称之为有副作用的行为，都建议放在componentDidMount中来执行。主要是因为state的改动会引发组件的重新渲染。\n\n\n![image](http://images2017.cnblogs.com/blog/1106982/201708/1106982-20170811224737742-1564011484.jpg)\n\n## PropTypes\n```\nimport PropTypes from 'prop-types';\n\nMyComponent.propTypes = {\n  // You can declare that a prop is a specific JS primitive. By default, these\n  // are all optional.\n  optionalArray: PropTypes.array,\n  optionalBool: PropTypes.bool,\n  optionalFunc: PropTypes.func,\n  optionalNumber: PropTypes.number,\n  optionalObject: PropTypes.object,\n  optionalString: PropTypes.string,\n  optionalSymbol: PropTypes.symbol,\n\n  // Anything that can be rendered: numbers, strings, elements or an array\n  // (or fragment) containing these types.\n  optionalNode: PropTypes.node,\n\n  // A React element.\n  optionalElement: PropTypes.element,\n\n  // You can also declare that a prop is an instance of a class. This uses\n  // JS's instanceof operator.\n  optionalMessage: PropTypes.instanceOf(Message),\n\n  // You can ensure that your prop is limited to specific values by treating\n  // it as an enum.\n  optionalEnum: PropTypes.oneOf(['News', 'Photos']),\n\n  // An object that could be one of many types\n  optionalUnion: PropTypes.oneOfType([\n    PropTypes.string,\n    PropTypes.number,\n    PropTypes.instanceOf(Message)\n  ]),\n\n  // An array of a certain type\n  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),\n\n  // An object with property values of a certain type\n  optionalObjectOf: PropTypes.objectOf(PropTypes.number),\n\n  // An object taking on a particular shape\n  optionalObjectWithShape: PropTypes.shape({\n    color: PropTypes.string,\n    fontSize: PropTypes.number\n  }),\n\n  // You can chain any of the above with `isRequired` to make sure a warning\n  // is shown if the prop isn't provided.\n  requiredFunc: PropTypes.func.isRequired,\n\n  // A value of any data type\n  requiredAny: PropTypes.any.isRequired,\n\n  // You can also specify a custom validator. It should return an Error\n  // object if the validation fails. Don't `console.warn` or throw, as this\n  // won't work inside `oneOfType`.\n  customProp: function(props, propName, componentName) {\n    if (!/matchme/.test(props[propName])) {\n      return new Error(\n        'Invalid prop `' + propName + '` supplied to' +\n        ' `' + componentName + '`. Validation failed.'\n      );\n    }\n  },\n\n  // You can also supply a custom validator to `arrayOf` and `objectOf`.\n  // It should return an Error object if the validation fails. The validator\n  // will be called for each key in the array or object. The first two\n  // arguments of the validator are the array or object itself, and the\n  // current item's key.\n  customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) {\n    if (!/matchme/.test(propValue[key])) {\n      return new Error(\n        'Invalid prop `' + propFullName + '` supplied to' +\n        ' `' + componentName + '`. Validation failed.'\n      );\n    }\n  })\n};\n```\n\n\t","source":"_posts/react基础2.md","raw":"---\ntitle: '''react基础2'''\ndate: 2018-05-09 17:49:24\ntags: react\n---\n\n\n[react官网](https://reactjs.org/docs/hello-world.html)\n\n## 组件\n#### 1. 无状态组件\n  - 在React中，组件的名字必须用大写字母开头，而包含该组件定义的文件名也应该是大写字母(便于区分，也可以不是)。\n  - 无状态组件是纯展示组件，仅仅只是用于数据的展示，只根据传入的props来进行展示，不涉及到state状态处理，通过函数式的方式来创建一个无状态函数式组件(大多数组件都是无状态组件，通过简单的组合可以构建成其他的组件，最后合并成一个大的应用)。\n  - 无状态函数式组件是一个只带有render方法的组件，通过函数形式或者箭头函数形式创建，该组件无state状态。\n\n```\nimport React from \"react\";\n\n//创建方式一,相当于es5的函数声明的方式创建\n function NoState (props) {\n     return (\n         <div>this is NoState Component</div>\n     )\n }\n```\n\n```\n//创建方式二,相当于es5的函数表达式的方式创建\nconst NoState = (props) => {\n    return (\n        <div>this is Nostate Component</div>\n    )\n}\n\nexport default NoState\n```\n--------------------------------------------------------------------------------\n- 无状态函数式组件没有组件实例化的过程，成为一个render方法的函数来执行，减少分配的内存，使整体渲染性能得到提高，因此展示数据的组件优先选择这种方式。\n- 无状态组件没有实例化得过程，因此无法访问组件this中的对象\n- 无状态组件不需要组件生命周期管理和状态管理，底层在实现这种形式的组件的时候不会实现组件的生命周期方法，所以无状态组件不能参与组件生命周期管理\n- 无状态组件只能访问传入的props，同样的props会得到同样的渲染结果\n\n<!-- more -->\n\n当我们的组件开始有逻辑处理，之前的那种方式胜任不了时索要采取的一种形式，通过继承react的Component对象而来\n代码的render方法，则是Component中，专门提供的用来处理jsx模板的方法。\n第一种方式不同的是，我们接收传入进来的参数，使用的是this.props，第一种方式将props放置于函数参数中，而这种方式则是将props挂载与实例对象上，因此会有所不同\n```\n// helloWorld.jsx\nimport React, {Component} from 'react';\nclass HelloWorld extends Component {\n    clickHander = () => {\n        console.log(this.props);\n        console.log(this.props.name);\n    }\n\n    render() {\n        return (\n            <div onClick={this.clickHander}>{ this.props.name } say: Hello World!</div>\n        )\n    }\n}\nexport default HelloWorld;\n```\n\n## 组件之间的交互\n#### 父组件与子组件之间的交互\n1. 父组件修改子组件，只需要修改传入的props属性\n2. 子组件修改父组件，需要父组件向子组件传递一个函数，该函数在父组件中定义，在子组件中触发执行\n子组件与子组件之间的交互\n3. 通过影响共同的父组件来进行交互\n\n\n\n```\nstate = {\n    switch: 0,\n    name: this.props.name1\n}\nclickHander = () => {\n    const {name1, name2} = this.props;\n    if (this.state.switch === 0) {\n        this.setState({\n            switch: 1,\n            name: name2\n        })\n    } else {\n        this.setState({\n            switch: 0,\n            name: name1\n        })\n    }\n};\nrender() {\n    return (\n        <div onClick={this.clickHander}>hello world !{this.state.name}</div>\n    )\n}\n```\n\n先来说说state相关的基础知识。首先了解ES6 class语法的同学都应该知道，当我们通过这种方式来写的时候，其实是将state写入了构造函数之中。\n\nstate = {} // 等同于ES5构造函数中的this.state = {}\n在对象中，我们可以通过this.state的方式来访问state中所存储的属性\nsetState接收一个对象，它的运行结果类似于执行一次assign方法。会修改传入的属性，而其他的属性则保持不变\nreact赋予state的特性，则是当state被修改时，会引起组件的一次重新渲染。即render方法会重新执行一次。也正是由于这个特性，因此当我们想要改变界面上的元素内容时，常常只需要改变state中的值就行了\n而setState也有一个非常重要的特性，那就是，该方法是异步的。它并不会立即执行，而会在下一轮事件循环中执行\n// 假设state.name的初始值为Tom，我们改变它的值this.setState({    name: 'Jason'})// 然后立即查看它的值console.log(this.state.name) // 仍然为Tom，不会立即改变\n\n### refs\nreact组件其实是虚拟DOM，因此通常我们需要通过特殊的方式才能拿到真正的DOM元素。大概说一说虚拟DOM是个什么形式存在的，它其实就是通过js对象的方式将DOM元素相关的都存储其实，比如一个div元素可能会是这样\n```\n// 当然可能命名会是其他的，大概表达一个意思，不深究哈\n{\n    nodeName: 'div',\n    className: 'hello-world',\n    style: {},\n    parentNodes: 'root',\n    childrenNodes: []\n    ...\n}\n```\n\n而我们想要拿到真实的DOM元素，react中提供了一种叫做ref的属性来实现这个目的\n```\nimport React, { Component } from 'react';\nclass HelloWorld extends Component {\n    clickHander = () => {\n        console.log(this.refs)\n    } \n    render () {\n        return (\n            <div className=\"container\" onClick={this.clickHander}>\n                <div ref=\"hello\" className=\"hello\">Hello</div>\n                <div ref=\"world\" className=\"world\">World</div>\n            </div>\n        )\n    }\n}\nexport default HelloWorld;\n```\n为了区分ES6语法中的class关键字，当我们在jsx中给元素添加class时，需要使用className来代替\n我们在jsx中，可以给元素添加ref属性，而这些拥有ref属性的元素，会统一放在组件对象的refs中，因此，当我们想要访问对应的真实DOM时，则通过this.refs来访问即可。\n当然，ref的值不仅仅可以为一个名字，同时还可以为一个回调函数，这个函数会在render渲染时执行，也就是说，每当render函数执行一次，ref的回调函数也会执行一次。\n```\n// src/helloWorld.jsx\nimport React, { Component } from 'react';class HelloWorld extends Component {\n    clickHander = () => {\n        console.log(this.refs)\n    } refCallback = (elem) => {\n        console.log(elem);\n    } render () {\n        return (\n            <div className=\"container\" onClick={this.clickHander}>\n                <div ref=\"hello\" className=\"hello\">Hello</div>\n                <div ref={this.refCallback} className=\"world\">World</div>\n            </div>\n        )\n    }\n}export default HelloWorld;\n```\n\n\n### 组件生命周期\n件的生命周期，指的就是一个组件，从创建到销毁的这样一个过程，react为组件的生命周期提供了很多的钩子函数\n\n##### react组件有三种状态：\n- Mounted：已经插入真实DOM\n- Updating：正在被重新渲染\n- Unmounted：已移出真实DOM\n- \n##### 每个状态的处理函数\n- will：函数在进入状态之前调用\n- did：函数在进入状态之后调用\n\n##### 组件第一次渲染完成的前后时刻，所谓的渲染完成，即组件已经被渲染成为真实DOM并插入到了html之中\n  - componentWillMount 在首次渲染完成之前，此时可修改组件的state\n  - componentDidMount 真实DOM渲染完成之后，该方法可通过this.getDOMNode()访问到真实的DOM元素，可以使用其他的类库来操作这个DOM\n\n##### 组件属性(我们前面提到的props与state)更新的前后时刻\n  - componentWillUpdate 接收到一个新的state或者props时，在重新render之前调用，此时不允许更新props和state\n  - componentDidUpdate 组件完成更新之后调用，此时可访问新的DOM元素\n\n###### 组件取消挂载之前(取消之后就没必要提供钩子函数了)\n`componentWillUnmount`\n\n###### 两个特殊的处理函数\n  - `componentWillReceiveProps(object nextProps)`：组件接收到新的props时，在重新render之前调用,此时可以更改props和state。首先props发生改变->然后componentWillReceiveProps去判断是否需要重新渲染(`shouldComponentUpdate`)->如果不需要则继续running->如果需要则执行`componentWillUpdate`->渲染DOM树之后执行`componentDidUpdate`->进入running\n  - `shouldComponentUpdate(nextProps, nextState)`(更新发生前立即被调用) 接收到一个新的state或者props时，在重新render之前调用，组件判断是否重新render前调用。首先state发生改变->判断是否需要重新渲染新的props和state(`shouldComponentUpdate`) -> 根据判断决定执行render过程还是继续·保持running状态\n\n###### 三个统一调用的方法,用于组件初始化，获取默认属性和状态\n  - getDefaultProps：作用于组件类，只调用一次，返回对象用于设置默认的props，对于引用值，会在实例中共享\n  - getInitialState：作用于组件的实例，在实例创建时只调用一次，，用于初始化没个实例的state，可访问this.props\n  - render：必选的方法，创建vistual DOM （1. 只能通过this.props和this.state访问数据 2. 可以返回null、false或任何React组件 3. 只能出现一个顶级组件（不能返回数组）4.不能改变组件的状态 5. 不能修改DOM的输出\n\n###### 已挂载的方法\n  - component.forceUpdate() 可以在任何已经挂载的组件上使用，当你知道某些深处的组件状态未通过this.setState而改变了的时候\n\n\n\n>componentDidMount，组件第一次渲染完成之后调用的componentDidMount，既然是组件第一次渲染完成之后才会调用，也就是说，该函数在react组件的生命周期中，只会调用一次。而渲染完成，则表示组件已经被渲染成为真实DOM插入了html中。所以这时候就可以通过ref获取真实元素。在实际开发中，常常需要通过ajax获取数据，而数据请求的这个行为，则最适合放在componentDidMount中来执行。通常会在首次渲染改变组件状态(state)的行为，或者称之为有副作用的行为，都建议放在componentDidMount中来执行。主要是因为state的改动会引发组件的重新渲染。\n\n\n![image](http://images2017.cnblogs.com/blog/1106982/201708/1106982-20170811224737742-1564011484.jpg)\n\n## PropTypes\n```\nimport PropTypes from 'prop-types';\n\nMyComponent.propTypes = {\n  // You can declare that a prop is a specific JS primitive. By default, these\n  // are all optional.\n  optionalArray: PropTypes.array,\n  optionalBool: PropTypes.bool,\n  optionalFunc: PropTypes.func,\n  optionalNumber: PropTypes.number,\n  optionalObject: PropTypes.object,\n  optionalString: PropTypes.string,\n  optionalSymbol: PropTypes.symbol,\n\n  // Anything that can be rendered: numbers, strings, elements or an array\n  // (or fragment) containing these types.\n  optionalNode: PropTypes.node,\n\n  // A React element.\n  optionalElement: PropTypes.element,\n\n  // You can also declare that a prop is an instance of a class. This uses\n  // JS's instanceof operator.\n  optionalMessage: PropTypes.instanceOf(Message),\n\n  // You can ensure that your prop is limited to specific values by treating\n  // it as an enum.\n  optionalEnum: PropTypes.oneOf(['News', 'Photos']),\n\n  // An object that could be one of many types\n  optionalUnion: PropTypes.oneOfType([\n    PropTypes.string,\n    PropTypes.number,\n    PropTypes.instanceOf(Message)\n  ]),\n\n  // An array of a certain type\n  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),\n\n  // An object with property values of a certain type\n  optionalObjectOf: PropTypes.objectOf(PropTypes.number),\n\n  // An object taking on a particular shape\n  optionalObjectWithShape: PropTypes.shape({\n    color: PropTypes.string,\n    fontSize: PropTypes.number\n  }),\n\n  // You can chain any of the above with `isRequired` to make sure a warning\n  // is shown if the prop isn't provided.\n  requiredFunc: PropTypes.func.isRequired,\n\n  // A value of any data type\n  requiredAny: PropTypes.any.isRequired,\n\n  // You can also specify a custom validator. It should return an Error\n  // object if the validation fails. Don't `console.warn` or throw, as this\n  // won't work inside `oneOfType`.\n  customProp: function(props, propName, componentName) {\n    if (!/matchme/.test(props[propName])) {\n      return new Error(\n        'Invalid prop `' + propName + '` supplied to' +\n        ' `' + componentName + '`. Validation failed.'\n      );\n    }\n  },\n\n  // You can also supply a custom validator to `arrayOf` and `objectOf`.\n  // It should return an Error object if the validation fails. The validator\n  // will be called for each key in the array or object. The first two\n  // arguments of the validator are the array or object itself, and the\n  // current item's key.\n  customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) {\n    if (!/matchme/.test(propValue[key])) {\n      return new Error(\n        'Invalid prop `' + propFullName + '` supplied to' +\n        ' `' + componentName + '`. Validation failed.'\n      );\n    }\n  })\n};\n```\n\n\t","slug":"react基础2","published":1,"updated":"2018-05-14T10:53:40.712Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjhag1ytl0005i0v6ycevpxci","content":"<p><a href=\"https://reactjs.org/docs/hello-world.html\" target=\"_blank\" rel=\"noopener\">react官网</a></p>\n<h2 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h2><h4 id=\"1-无状态组件\"><a href=\"#1-无状态组件\" class=\"headerlink\" title=\"1. 无状态组件\"></a>1. 无状态组件</h4><ul>\n<li>在React中，组件的名字必须用大写字母开头，而包含该组件定义的文件名也应该是大写字母(便于区分，也可以不是)。</li>\n<li>无状态组件是纯展示组件，仅仅只是用于数据的展示，只根据传入的props来进行展示，不涉及到state状态处理，通过函数式的方式来创建一个无状态函数式组件(大多数组件都是无状态组件，通过简单的组合可以构建成其他的组件，最后合并成一个大的应用)。</li>\n<li>无状态函数式组件是一个只带有render方法的组件，通过函数形式或者箭头函数形式创建，该组件无state状态。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React from &quot;react&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">//创建方式一,相当于es5的函数声明的方式创建</span><br><span class=\"line\"> function NoState (props) &#123;</span><br><span class=\"line\">     return (</span><br><span class=\"line\">         &lt;div&gt;this is NoState Component&lt;/div&gt;</span><br><span class=\"line\">     )</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//创建方式二,相当于es5的函数表达式的方式创建</span><br><span class=\"line\">const NoState = (props) =&gt; &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">        &lt;div&gt;this is Nostate Component&lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default NoState</span><br></pre></td></tr></table></figure>\n<hr>\n<ul>\n<li>无状态函数式组件没有组件实例化的过程，成为一个render方法的函数来执行，减少分配的内存，使整体渲染性能得到提高，因此展示数据的组件优先选择这种方式。</li>\n<li>无状态组件没有实例化得过程，因此无法访问组件this中的对象</li>\n<li>无状态组件不需要组件生命周期管理和状态管理，底层在实现这种形式的组件的时候不会实现组件的生命周期方法，所以无状态组件不能参与组件生命周期管理</li>\n<li>无状态组件只能访问传入的props，同样的props会得到同样的渲染结果</li>\n</ul>\n<a id=\"more\"></a>\n<p>当我们的组件开始有逻辑处理，之前的那种方式胜任不了时索要采取的一种形式，通过继承react的Component对象而来<br>代码的render方法，则是Component中，专门提供的用来处理jsx模板的方法。<br>第一种方式不同的是，我们接收传入进来的参数，使用的是this.props，第一种方式将props放置于函数参数中，而这种方式则是将props挂载与实例对象上，因此会有所不同<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// helloWorld.jsx</span><br><span class=\"line\">import React, &#123;Component&#125; from &apos;react&apos;;</span><br><span class=\"line\">class HelloWorld extends Component &#123;</span><br><span class=\"line\">    clickHander = () =&gt; &#123;</span><br><span class=\"line\">        console.log(this.props);</span><br><span class=\"line\">        console.log(this.props.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;div onClick=&#123;this.clickHander&#125;&gt;&#123; this.props.name &#125; say: Hello World!&lt;/div&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export default HelloWorld;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"组件之间的交互\"><a href=\"#组件之间的交互\" class=\"headerlink\" title=\"组件之间的交互\"></a>组件之间的交互</h2><h4 id=\"父组件与子组件之间的交互\"><a href=\"#父组件与子组件之间的交互\" class=\"headerlink\" title=\"父组件与子组件之间的交互\"></a>父组件与子组件之间的交互</h4><ol>\n<li>父组件修改子组件，只需要修改传入的props属性</li>\n<li>子组件修改父组件，需要父组件向子组件传递一个函数，该函数在父组件中定义，在子组件中触发执行<br>子组件与子组件之间的交互</li>\n<li>通过影响共同的父组件来进行交互</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">state = &#123;</span><br><span class=\"line\">    switch: 0,</span><br><span class=\"line\">    name: this.props.name1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">clickHander = () =&gt; &#123;</span><br><span class=\"line\">    const &#123;name1, name2&#125; = this.props;</span><br><span class=\"line\">    if (this.state.switch === 0) &#123;</span><br><span class=\"line\">        this.setState(&#123;</span><br><span class=\"line\">            switch: 1,</span><br><span class=\"line\">            name: name2</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        this.setState(&#123;</span><br><span class=\"line\">            switch: 0,</span><br><span class=\"line\">            name: name1</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">render() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">        &lt;div onClick=&#123;this.clickHander&#125;&gt;hello world !&#123;this.state.name&#125;&lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>先来说说state相关的基础知识。首先了解ES6 class语法的同学都应该知道，当我们通过这种方式来写的时候，其实是将state写入了构造函数之中。</p>\n<p>state = {} // 等同于ES5构造函数中的this.state = {}<br>在对象中，我们可以通过this.state的方式来访问state中所存储的属性<br>setState接收一个对象，它的运行结果类似于执行一次assign方法。会修改传入的属性，而其他的属性则保持不变<br>react赋予state的特性，则是当state被修改时，会引起组件的一次重新渲染。即render方法会重新执行一次。也正是由于这个特性，因此当我们想要改变界面上的元素内容时，常常只需要改变state中的值就行了<br>而setState也有一个非常重要的特性，那就是，该方法是异步的。它并不会立即执行，而会在下一轮事件循环中执行<br>// 假设state.name的初始值为Tom，我们改变它的值this.setState({    name: ‘Jason’})// 然后立即查看它的值console.log(this.state.name) // 仍然为Tom，不会立即改变</p>\n<h3 id=\"refs\"><a href=\"#refs\" class=\"headerlink\" title=\"refs\"></a>refs</h3><p>react组件其实是虚拟DOM，因此通常我们需要通过特殊的方式才能拿到真正的DOM元素。大概说一说虚拟DOM是个什么形式存在的，它其实就是通过js对象的方式将DOM元素相关的都存储其实，比如一个div元素可能会是这样<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 当然可能命名会是其他的，大概表达一个意思，不深究哈</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    nodeName: &apos;div&apos;,</span><br><span class=\"line\">    className: &apos;hello-world&apos;,</span><br><span class=\"line\">    style: &#123;&#125;,</span><br><span class=\"line\">    parentNodes: &apos;root&apos;,</span><br><span class=\"line\">    childrenNodes: []</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>而我们想要拿到真实的DOM元素，react中提供了一种叫做ref的属性来实现这个目的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class=\"line\">class HelloWorld extends Component &#123;</span><br><span class=\"line\">    clickHander = () =&gt; &#123;</span><br><span class=\"line\">        console.log(this.refs)</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    render () &#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;div className=&quot;container&quot; onClick=&#123;this.clickHander&#125;&gt;</span><br><span class=\"line\">                &lt;div ref=&quot;hello&quot; className=&quot;hello&quot;&gt;Hello&lt;/div&gt;</span><br><span class=\"line\">                &lt;div ref=&quot;world&quot; className=&quot;world&quot;&gt;World&lt;/div&gt;</span><br><span class=\"line\">            &lt;/div&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export default HelloWorld;</span><br></pre></td></tr></table></figure></p>\n<p>为了区分ES6语法中的class关键字，当我们在jsx中给元素添加class时，需要使用className来代替<br>我们在jsx中，可以给元素添加ref属性，而这些拥有ref属性的元素，会统一放在组件对象的refs中，因此，当我们想要访问对应的真实DOM时，则通过this.refs来访问即可。<br>当然，ref的值不仅仅可以为一个名字，同时还可以为一个回调函数，这个函数会在render渲染时执行，也就是说，每当render函数执行一次，ref的回调函数也会执行一次。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// src/helloWorld.jsx</span><br><span class=\"line\">import React, &#123; Component &#125; from &apos;react&apos;;class HelloWorld extends Component &#123;</span><br><span class=\"line\">    clickHander = () =&gt; &#123;</span><br><span class=\"line\">        console.log(this.refs)</span><br><span class=\"line\">    &#125; refCallback = (elem) =&gt; &#123;</span><br><span class=\"line\">        console.log(elem);</span><br><span class=\"line\">    &#125; render () &#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;div className=&quot;container&quot; onClick=&#123;this.clickHander&#125;&gt;</span><br><span class=\"line\">                &lt;div ref=&quot;hello&quot; className=&quot;hello&quot;&gt;Hello&lt;/div&gt;</span><br><span class=\"line\">                &lt;div ref=&#123;this.refCallback&#125; className=&quot;world&quot;&gt;World&lt;/div&gt;</span><br><span class=\"line\">            &lt;/div&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;export default HelloWorld;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"组件生命周期\"><a href=\"#组件生命周期\" class=\"headerlink\" title=\"组件生命周期\"></a>组件生命周期</h3><p>件的生命周期，指的就是一个组件，从创建到销毁的这样一个过程，react为组件的生命周期提供了很多的钩子函数</p>\n<h5 id=\"react组件有三种状态：\"><a href=\"#react组件有三种状态：\" class=\"headerlink\" title=\"react组件有三种状态：\"></a>react组件有三种状态：</h5><ul>\n<li>Mounted：已经插入真实DOM</li>\n<li>Updating：正在被重新渲染</li>\n<li>Unmounted：已移出真实DOM</li>\n<li><h5 id=\"每个状态的处理函数\"><a href=\"#每个状态的处理函数\" class=\"headerlink\" title=\"每个状态的处理函数\"></a>每个状态的处理函数</h5></li>\n<li>will：函数在进入状态之前调用</li>\n<li>did：函数在进入状态之后调用</li>\n</ul>\n<h5 id=\"组件第一次渲染完成的前后时刻，所谓的渲染完成，即组件已经被渲染成为真实DOM并插入到了html之中\"><a href=\"#组件第一次渲染完成的前后时刻，所谓的渲染完成，即组件已经被渲染成为真实DOM并插入到了html之中\" class=\"headerlink\" title=\"组件第一次渲染完成的前后时刻，所谓的渲染完成，即组件已经被渲染成为真实DOM并插入到了html之中\"></a>组件第一次渲染完成的前后时刻，所谓的渲染完成，即组件已经被渲染成为真实DOM并插入到了html之中</h5><ul>\n<li>componentWillMount 在首次渲染完成之前，此时可修改组件的state</li>\n<li>componentDidMount 真实DOM渲染完成之后，该方法可通过this.getDOMNode()访问到真实的DOM元素，可以使用其他的类库来操作这个DOM</li>\n</ul>\n<h5 id=\"组件属性-我们前面提到的props与state-更新的前后时刻\"><a href=\"#组件属性-我们前面提到的props与state-更新的前后时刻\" class=\"headerlink\" title=\"组件属性(我们前面提到的props与state)更新的前后时刻\"></a>组件属性(我们前面提到的props与state)更新的前后时刻</h5><ul>\n<li>componentWillUpdate 接收到一个新的state或者props时，在重新render之前调用，此时不允许更新props和state</li>\n<li>componentDidUpdate 组件完成更新之后调用，此时可访问新的DOM元素</li>\n</ul>\n<h6 id=\"组件取消挂载之前-取消之后就没必要提供钩子函数了\"><a href=\"#组件取消挂载之前-取消之后就没必要提供钩子函数了\" class=\"headerlink\" title=\"组件取消挂载之前(取消之后就没必要提供钩子函数了)\"></a>组件取消挂载之前(取消之后就没必要提供钩子函数了)</h6><p><code>componentWillUnmount</code></p>\n<h6 id=\"两个特殊的处理函数\"><a href=\"#两个特殊的处理函数\" class=\"headerlink\" title=\"两个特殊的处理函数\"></a>两个特殊的处理函数</h6><ul>\n<li><code>componentWillReceiveProps(object nextProps)</code>：组件接收到新的props时，在重新render之前调用,此时可以更改props和state。首先props发生改变-&gt;然后componentWillReceiveProps去判断是否需要重新渲染(<code>shouldComponentUpdate</code>)-&gt;如果不需要则继续running-&gt;如果需要则执行<code>componentWillUpdate</code>-&gt;渲染DOM树之后执行<code>componentDidUpdate</code>-&gt;进入running</li>\n<li><code>shouldComponentUpdate(nextProps, nextState)</code>(更新发生前立即被调用) 接收到一个新的state或者props时，在重新render之前调用，组件判断是否重新render前调用。首先state发生改变-&gt;判断是否需要重新渲染新的props和state(<code>shouldComponentUpdate</code>) -&gt; 根据判断决定执行render过程还是继续·保持running状态</li>\n</ul>\n<h6 id=\"三个统一调用的方法-用于组件初始化，获取默认属性和状态\"><a href=\"#三个统一调用的方法-用于组件初始化，获取默认属性和状态\" class=\"headerlink\" title=\"三个统一调用的方法,用于组件初始化，获取默认属性和状态\"></a>三个统一调用的方法,用于组件初始化，获取默认属性和状态</h6><ul>\n<li>getDefaultProps：作用于组件类，只调用一次，返回对象用于设置默认的props，对于引用值，会在实例中共享</li>\n<li>getInitialState：作用于组件的实例，在实例创建时只调用一次，，用于初始化没个实例的state，可访问this.props</li>\n<li>render：必选的方法，创建vistual DOM （1. 只能通过this.props和this.state访问数据 2. 可以返回null、false或任何React组件 3. 只能出现一个顶级组件（不能返回数组）4.不能改变组件的状态 5. 不能修改DOM的输出</li>\n</ul>\n<h6 id=\"已挂载的方法\"><a href=\"#已挂载的方法\" class=\"headerlink\" title=\"已挂载的方法\"></a>已挂载的方法</h6><ul>\n<li>component.forceUpdate() 可以在任何已经挂载的组件上使用，当你知道某些深处的组件状态未通过this.setState而改变了的时候</li>\n</ul>\n<blockquote>\n<p>componentDidMount，组件第一次渲染完成之后调用的componentDidMount，既然是组件第一次渲染完成之后才会调用，也就是说，该函数在react组件的生命周期中，只会调用一次。而渲染完成，则表示组件已经被渲染成为真实DOM插入了html中。所以这时候就可以通过ref获取真实元素。在实际开发中，常常需要通过ajax获取数据，而数据请求的这个行为，则最适合放在componentDidMount中来执行。通常会在首次渲染改变组件状态(state)的行为，或者称之为有副作用的行为，都建议放在componentDidMount中来执行。主要是因为state的改动会引发组件的重新渲染。</p>\n</blockquote>\n<p><img src=\"http://images2017.cnblogs.com/blog/1106982/201708/1106982-20170811224737742-1564011484.jpg\" alt=\"image\"></p>\n<h2 id=\"PropTypes\"><a href=\"#PropTypes\" class=\"headerlink\" title=\"PropTypes\"></a>PropTypes</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import PropTypes from &apos;prop-types&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">MyComponent.propTypes = &#123;</span><br><span class=\"line\">  // You can declare that a prop is a specific JS primitive. By default, these</span><br><span class=\"line\">  // are all optional.</span><br><span class=\"line\">  optionalArray: PropTypes.array,</span><br><span class=\"line\">  optionalBool: PropTypes.bool,</span><br><span class=\"line\">  optionalFunc: PropTypes.func,</span><br><span class=\"line\">  optionalNumber: PropTypes.number,</span><br><span class=\"line\">  optionalObject: PropTypes.object,</span><br><span class=\"line\">  optionalString: PropTypes.string,</span><br><span class=\"line\">  optionalSymbol: PropTypes.symbol,</span><br><span class=\"line\"></span><br><span class=\"line\">  // Anything that can be rendered: numbers, strings, elements or an array</span><br><span class=\"line\">  // (or fragment) containing these types.</span><br><span class=\"line\">  optionalNode: PropTypes.node,</span><br><span class=\"line\"></span><br><span class=\"line\">  // A React element.</span><br><span class=\"line\">  optionalElement: PropTypes.element,</span><br><span class=\"line\"></span><br><span class=\"line\">  // You can also declare that a prop is an instance of a class. This uses</span><br><span class=\"line\">  // JS&apos;s instanceof operator.</span><br><span class=\"line\">  optionalMessage: PropTypes.instanceOf(Message),</span><br><span class=\"line\"></span><br><span class=\"line\">  // You can ensure that your prop is limited to specific values by treating</span><br><span class=\"line\">  // it as an enum.</span><br><span class=\"line\">  optionalEnum: PropTypes.oneOf([&apos;News&apos;, &apos;Photos&apos;]),</span><br><span class=\"line\"></span><br><span class=\"line\">  // An object that could be one of many types</span><br><span class=\"line\">  optionalUnion: PropTypes.oneOfType([</span><br><span class=\"line\">    PropTypes.string,</span><br><span class=\"line\">    PropTypes.number,</span><br><span class=\"line\">    PropTypes.instanceOf(Message)</span><br><span class=\"line\">  ]),</span><br><span class=\"line\"></span><br><span class=\"line\">  // An array of a certain type</span><br><span class=\"line\">  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),</span><br><span class=\"line\"></span><br><span class=\"line\">  // An object with property values of a certain type</span><br><span class=\"line\">  optionalObjectOf: PropTypes.objectOf(PropTypes.number),</span><br><span class=\"line\"></span><br><span class=\"line\">  // An object taking on a particular shape</span><br><span class=\"line\">  optionalObjectWithShape: PropTypes.shape(&#123;</span><br><span class=\"line\">    color: PropTypes.string,</span><br><span class=\"line\">    fontSize: PropTypes.number</span><br><span class=\"line\">  &#125;),</span><br><span class=\"line\"></span><br><span class=\"line\">  // You can chain any of the above with `isRequired` to make sure a warning</span><br><span class=\"line\">  // is shown if the prop isn&apos;t provided.</span><br><span class=\"line\">  requiredFunc: PropTypes.func.isRequired,</span><br><span class=\"line\"></span><br><span class=\"line\">  // A value of any data type</span><br><span class=\"line\">  requiredAny: PropTypes.any.isRequired,</span><br><span class=\"line\"></span><br><span class=\"line\">  // You can also specify a custom validator. It should return an Error</span><br><span class=\"line\">  // object if the validation fails. Don&apos;t `console.warn` or throw, as this</span><br><span class=\"line\">  // won&apos;t work inside `oneOfType`.</span><br><span class=\"line\">  customProp: function(props, propName, componentName) &#123;</span><br><span class=\"line\">    if (!/matchme/.test(props[propName])) &#123;</span><br><span class=\"line\">      return new Error(</span><br><span class=\"line\">        &apos;Invalid prop `&apos; + propName + &apos;` supplied to&apos; +</span><br><span class=\"line\">        &apos; `&apos; + componentName + &apos;`. Validation failed.&apos;</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // You can also supply a custom validator to `arrayOf` and `objectOf`.</span><br><span class=\"line\">  // It should return an Error object if the validation fails. The validator</span><br><span class=\"line\">  // will be called for each key in the array or object. The first two</span><br><span class=\"line\">  // arguments of the validator are the array or object itself, and the</span><br><span class=\"line\">  // current item&apos;s key.</span><br><span class=\"line\">  customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) &#123;</span><br><span class=\"line\">    if (!/matchme/.test(propValue[key])) &#123;</span><br><span class=\"line\">      return new Error(</span><br><span class=\"line\">        &apos;Invalid prop `&apos; + propFullName + &apos;` supplied to&apos; +</span><br><span class=\"line\">        &apos; `&apos; + componentName + &apos;`. Validation failed.&apos;</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://reactjs.org/docs/hello-world.html\" target=\"_blank\" rel=\"noopener\">react官网</a></p>\n<h2 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h2><h4 id=\"1-无状态组件\"><a href=\"#1-无状态组件\" class=\"headerlink\" title=\"1. 无状态组件\"></a>1. 无状态组件</h4><ul>\n<li>在React中，组件的名字必须用大写字母开头，而包含该组件定义的文件名也应该是大写字母(便于区分，也可以不是)。</li>\n<li>无状态组件是纯展示组件，仅仅只是用于数据的展示，只根据传入的props来进行展示，不涉及到state状态处理，通过函数式的方式来创建一个无状态函数式组件(大多数组件都是无状态组件，通过简单的组合可以构建成其他的组件，最后合并成一个大的应用)。</li>\n<li>无状态函数式组件是一个只带有render方法的组件，通过函数形式或者箭头函数形式创建，该组件无state状态。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React from &quot;react&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">//创建方式一,相当于es5的函数声明的方式创建</span><br><span class=\"line\"> function NoState (props) &#123;</span><br><span class=\"line\">     return (</span><br><span class=\"line\">         &lt;div&gt;this is NoState Component&lt;/div&gt;</span><br><span class=\"line\">     )</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//创建方式二,相当于es5的函数表达式的方式创建</span><br><span class=\"line\">const NoState = (props) =&gt; &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">        &lt;div&gt;this is Nostate Component&lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default NoState</span><br></pre></td></tr></table></figure>\n<hr>\n<ul>\n<li>无状态函数式组件没有组件实例化的过程，成为一个render方法的函数来执行，减少分配的内存，使整体渲染性能得到提高，因此展示数据的组件优先选择这种方式。</li>\n<li>无状态组件没有实例化得过程，因此无法访问组件this中的对象</li>\n<li>无状态组件不需要组件生命周期管理和状态管理，底层在实现这种形式的组件的时候不会实现组件的生命周期方法，所以无状态组件不能参与组件生命周期管理</li>\n<li>无状态组件只能访问传入的props，同样的props会得到同样的渲染结果</li>\n</ul>","more":"<p>当我们的组件开始有逻辑处理，之前的那种方式胜任不了时索要采取的一种形式，通过继承react的Component对象而来<br>代码的render方法，则是Component中，专门提供的用来处理jsx模板的方法。<br>第一种方式不同的是，我们接收传入进来的参数，使用的是this.props，第一种方式将props放置于函数参数中，而这种方式则是将props挂载与实例对象上，因此会有所不同<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// helloWorld.jsx</span><br><span class=\"line\">import React, &#123;Component&#125; from &apos;react&apos;;</span><br><span class=\"line\">class HelloWorld extends Component &#123;</span><br><span class=\"line\">    clickHander = () =&gt; &#123;</span><br><span class=\"line\">        console.log(this.props);</span><br><span class=\"line\">        console.log(this.props.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;div onClick=&#123;this.clickHander&#125;&gt;&#123; this.props.name &#125; say: Hello World!&lt;/div&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export default HelloWorld;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"组件之间的交互\"><a href=\"#组件之间的交互\" class=\"headerlink\" title=\"组件之间的交互\"></a>组件之间的交互</h2><h4 id=\"父组件与子组件之间的交互\"><a href=\"#父组件与子组件之间的交互\" class=\"headerlink\" title=\"父组件与子组件之间的交互\"></a>父组件与子组件之间的交互</h4><ol>\n<li>父组件修改子组件，只需要修改传入的props属性</li>\n<li>子组件修改父组件，需要父组件向子组件传递一个函数，该函数在父组件中定义，在子组件中触发执行<br>子组件与子组件之间的交互</li>\n<li>通过影响共同的父组件来进行交互</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">state = &#123;</span><br><span class=\"line\">    switch: 0,</span><br><span class=\"line\">    name: this.props.name1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">clickHander = () =&gt; &#123;</span><br><span class=\"line\">    const &#123;name1, name2&#125; = this.props;</span><br><span class=\"line\">    if (this.state.switch === 0) &#123;</span><br><span class=\"line\">        this.setState(&#123;</span><br><span class=\"line\">            switch: 1,</span><br><span class=\"line\">            name: name2</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        this.setState(&#123;</span><br><span class=\"line\">            switch: 0,</span><br><span class=\"line\">            name: name1</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">render() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">        &lt;div onClick=&#123;this.clickHander&#125;&gt;hello world !&#123;this.state.name&#125;&lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>先来说说state相关的基础知识。首先了解ES6 class语法的同学都应该知道，当我们通过这种方式来写的时候，其实是将state写入了构造函数之中。</p>\n<p>state = {} // 等同于ES5构造函数中的this.state = {}<br>在对象中，我们可以通过this.state的方式来访问state中所存储的属性<br>setState接收一个对象，它的运行结果类似于执行一次assign方法。会修改传入的属性，而其他的属性则保持不变<br>react赋予state的特性，则是当state被修改时，会引起组件的一次重新渲染。即render方法会重新执行一次。也正是由于这个特性，因此当我们想要改变界面上的元素内容时，常常只需要改变state中的值就行了<br>而setState也有一个非常重要的特性，那就是，该方法是异步的。它并不会立即执行，而会在下一轮事件循环中执行<br>// 假设state.name的初始值为Tom，我们改变它的值this.setState({    name: ‘Jason’})// 然后立即查看它的值console.log(this.state.name) // 仍然为Tom，不会立即改变</p>\n<h3 id=\"refs\"><a href=\"#refs\" class=\"headerlink\" title=\"refs\"></a>refs</h3><p>react组件其实是虚拟DOM，因此通常我们需要通过特殊的方式才能拿到真正的DOM元素。大概说一说虚拟DOM是个什么形式存在的，它其实就是通过js对象的方式将DOM元素相关的都存储其实，比如一个div元素可能会是这样<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 当然可能命名会是其他的，大概表达一个意思，不深究哈</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    nodeName: &apos;div&apos;,</span><br><span class=\"line\">    className: &apos;hello-world&apos;,</span><br><span class=\"line\">    style: &#123;&#125;,</span><br><span class=\"line\">    parentNodes: &apos;root&apos;,</span><br><span class=\"line\">    childrenNodes: []</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>而我们想要拿到真实的DOM元素，react中提供了一种叫做ref的属性来实现这个目的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class=\"line\">class HelloWorld extends Component &#123;</span><br><span class=\"line\">    clickHander = () =&gt; &#123;</span><br><span class=\"line\">        console.log(this.refs)</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    render () &#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;div className=&quot;container&quot; onClick=&#123;this.clickHander&#125;&gt;</span><br><span class=\"line\">                &lt;div ref=&quot;hello&quot; className=&quot;hello&quot;&gt;Hello&lt;/div&gt;</span><br><span class=\"line\">                &lt;div ref=&quot;world&quot; className=&quot;world&quot;&gt;World&lt;/div&gt;</span><br><span class=\"line\">            &lt;/div&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export default HelloWorld;</span><br></pre></td></tr></table></figure></p>\n<p>为了区分ES6语法中的class关键字，当我们在jsx中给元素添加class时，需要使用className来代替<br>我们在jsx中，可以给元素添加ref属性，而这些拥有ref属性的元素，会统一放在组件对象的refs中，因此，当我们想要访问对应的真实DOM时，则通过this.refs来访问即可。<br>当然，ref的值不仅仅可以为一个名字，同时还可以为一个回调函数，这个函数会在render渲染时执行，也就是说，每当render函数执行一次，ref的回调函数也会执行一次。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// src/helloWorld.jsx</span><br><span class=\"line\">import React, &#123; Component &#125; from &apos;react&apos;;class HelloWorld extends Component &#123;</span><br><span class=\"line\">    clickHander = () =&gt; &#123;</span><br><span class=\"line\">        console.log(this.refs)</span><br><span class=\"line\">    &#125; refCallback = (elem) =&gt; &#123;</span><br><span class=\"line\">        console.log(elem);</span><br><span class=\"line\">    &#125; render () &#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;div className=&quot;container&quot; onClick=&#123;this.clickHander&#125;&gt;</span><br><span class=\"line\">                &lt;div ref=&quot;hello&quot; className=&quot;hello&quot;&gt;Hello&lt;/div&gt;</span><br><span class=\"line\">                &lt;div ref=&#123;this.refCallback&#125; className=&quot;world&quot;&gt;World&lt;/div&gt;</span><br><span class=\"line\">            &lt;/div&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;export default HelloWorld;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"组件生命周期\"><a href=\"#组件生命周期\" class=\"headerlink\" title=\"组件生命周期\"></a>组件生命周期</h3><p>件的生命周期，指的就是一个组件，从创建到销毁的这样一个过程，react为组件的生命周期提供了很多的钩子函数</p>\n<h5 id=\"react组件有三种状态：\"><a href=\"#react组件有三种状态：\" class=\"headerlink\" title=\"react组件有三种状态：\"></a>react组件有三种状态：</h5><ul>\n<li>Mounted：已经插入真实DOM</li>\n<li>Updating：正在被重新渲染</li>\n<li>Unmounted：已移出真实DOM</li>\n<li><h5 id=\"每个状态的处理函数\"><a href=\"#每个状态的处理函数\" class=\"headerlink\" title=\"每个状态的处理函数\"></a>每个状态的处理函数</h5></li>\n<li>will：函数在进入状态之前调用</li>\n<li>did：函数在进入状态之后调用</li>\n</ul>\n<h5 id=\"组件第一次渲染完成的前后时刻，所谓的渲染完成，即组件已经被渲染成为真实DOM并插入到了html之中\"><a href=\"#组件第一次渲染完成的前后时刻，所谓的渲染完成，即组件已经被渲染成为真实DOM并插入到了html之中\" class=\"headerlink\" title=\"组件第一次渲染完成的前后时刻，所谓的渲染完成，即组件已经被渲染成为真实DOM并插入到了html之中\"></a>组件第一次渲染完成的前后时刻，所谓的渲染完成，即组件已经被渲染成为真实DOM并插入到了html之中</h5><ul>\n<li>componentWillMount 在首次渲染完成之前，此时可修改组件的state</li>\n<li>componentDidMount 真实DOM渲染完成之后，该方法可通过this.getDOMNode()访问到真实的DOM元素，可以使用其他的类库来操作这个DOM</li>\n</ul>\n<h5 id=\"组件属性-我们前面提到的props与state-更新的前后时刻\"><a href=\"#组件属性-我们前面提到的props与state-更新的前后时刻\" class=\"headerlink\" title=\"组件属性(我们前面提到的props与state)更新的前后时刻\"></a>组件属性(我们前面提到的props与state)更新的前后时刻</h5><ul>\n<li>componentWillUpdate 接收到一个新的state或者props时，在重新render之前调用，此时不允许更新props和state</li>\n<li>componentDidUpdate 组件完成更新之后调用，此时可访问新的DOM元素</li>\n</ul>\n<h6 id=\"组件取消挂载之前-取消之后就没必要提供钩子函数了\"><a href=\"#组件取消挂载之前-取消之后就没必要提供钩子函数了\" class=\"headerlink\" title=\"组件取消挂载之前(取消之后就没必要提供钩子函数了)\"></a>组件取消挂载之前(取消之后就没必要提供钩子函数了)</h6><p><code>componentWillUnmount</code></p>\n<h6 id=\"两个特殊的处理函数\"><a href=\"#两个特殊的处理函数\" class=\"headerlink\" title=\"两个特殊的处理函数\"></a>两个特殊的处理函数</h6><ul>\n<li><code>componentWillReceiveProps(object nextProps)</code>：组件接收到新的props时，在重新render之前调用,此时可以更改props和state。首先props发生改变-&gt;然后componentWillReceiveProps去判断是否需要重新渲染(<code>shouldComponentUpdate</code>)-&gt;如果不需要则继续running-&gt;如果需要则执行<code>componentWillUpdate</code>-&gt;渲染DOM树之后执行<code>componentDidUpdate</code>-&gt;进入running</li>\n<li><code>shouldComponentUpdate(nextProps, nextState)</code>(更新发生前立即被调用) 接收到一个新的state或者props时，在重新render之前调用，组件判断是否重新render前调用。首先state发生改变-&gt;判断是否需要重新渲染新的props和state(<code>shouldComponentUpdate</code>) -&gt; 根据判断决定执行render过程还是继续·保持running状态</li>\n</ul>\n<h6 id=\"三个统一调用的方法-用于组件初始化，获取默认属性和状态\"><a href=\"#三个统一调用的方法-用于组件初始化，获取默认属性和状态\" class=\"headerlink\" title=\"三个统一调用的方法,用于组件初始化，获取默认属性和状态\"></a>三个统一调用的方法,用于组件初始化，获取默认属性和状态</h6><ul>\n<li>getDefaultProps：作用于组件类，只调用一次，返回对象用于设置默认的props，对于引用值，会在实例中共享</li>\n<li>getInitialState：作用于组件的实例，在实例创建时只调用一次，，用于初始化没个实例的state，可访问this.props</li>\n<li>render：必选的方法，创建vistual DOM （1. 只能通过this.props和this.state访问数据 2. 可以返回null、false或任何React组件 3. 只能出现一个顶级组件（不能返回数组）4.不能改变组件的状态 5. 不能修改DOM的输出</li>\n</ul>\n<h6 id=\"已挂载的方法\"><a href=\"#已挂载的方法\" class=\"headerlink\" title=\"已挂载的方法\"></a>已挂载的方法</h6><ul>\n<li>component.forceUpdate() 可以在任何已经挂载的组件上使用，当你知道某些深处的组件状态未通过this.setState而改变了的时候</li>\n</ul>\n<blockquote>\n<p>componentDidMount，组件第一次渲染完成之后调用的componentDidMount，既然是组件第一次渲染完成之后才会调用，也就是说，该函数在react组件的生命周期中，只会调用一次。而渲染完成，则表示组件已经被渲染成为真实DOM插入了html中。所以这时候就可以通过ref获取真实元素。在实际开发中，常常需要通过ajax获取数据，而数据请求的这个行为，则最适合放在componentDidMount中来执行。通常会在首次渲染改变组件状态(state)的行为，或者称之为有副作用的行为，都建议放在componentDidMount中来执行。主要是因为state的改动会引发组件的重新渲染。</p>\n</blockquote>\n<p><img src=\"http://images2017.cnblogs.com/blog/1106982/201708/1106982-20170811224737742-1564011484.jpg\" alt=\"image\"></p>\n<h2 id=\"PropTypes\"><a href=\"#PropTypes\" class=\"headerlink\" title=\"PropTypes\"></a>PropTypes</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import PropTypes from &apos;prop-types&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">MyComponent.propTypes = &#123;</span><br><span class=\"line\">  // You can declare that a prop is a specific JS primitive. By default, these</span><br><span class=\"line\">  // are all optional.</span><br><span class=\"line\">  optionalArray: PropTypes.array,</span><br><span class=\"line\">  optionalBool: PropTypes.bool,</span><br><span class=\"line\">  optionalFunc: PropTypes.func,</span><br><span class=\"line\">  optionalNumber: PropTypes.number,</span><br><span class=\"line\">  optionalObject: PropTypes.object,</span><br><span class=\"line\">  optionalString: PropTypes.string,</span><br><span class=\"line\">  optionalSymbol: PropTypes.symbol,</span><br><span class=\"line\"></span><br><span class=\"line\">  // Anything that can be rendered: numbers, strings, elements or an array</span><br><span class=\"line\">  // (or fragment) containing these types.</span><br><span class=\"line\">  optionalNode: PropTypes.node,</span><br><span class=\"line\"></span><br><span class=\"line\">  // A React element.</span><br><span class=\"line\">  optionalElement: PropTypes.element,</span><br><span class=\"line\"></span><br><span class=\"line\">  // You can also declare that a prop is an instance of a class. This uses</span><br><span class=\"line\">  // JS&apos;s instanceof operator.</span><br><span class=\"line\">  optionalMessage: PropTypes.instanceOf(Message),</span><br><span class=\"line\"></span><br><span class=\"line\">  // You can ensure that your prop is limited to specific values by treating</span><br><span class=\"line\">  // it as an enum.</span><br><span class=\"line\">  optionalEnum: PropTypes.oneOf([&apos;News&apos;, &apos;Photos&apos;]),</span><br><span class=\"line\"></span><br><span class=\"line\">  // An object that could be one of many types</span><br><span class=\"line\">  optionalUnion: PropTypes.oneOfType([</span><br><span class=\"line\">    PropTypes.string,</span><br><span class=\"line\">    PropTypes.number,</span><br><span class=\"line\">    PropTypes.instanceOf(Message)</span><br><span class=\"line\">  ]),</span><br><span class=\"line\"></span><br><span class=\"line\">  // An array of a certain type</span><br><span class=\"line\">  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),</span><br><span class=\"line\"></span><br><span class=\"line\">  // An object with property values of a certain type</span><br><span class=\"line\">  optionalObjectOf: PropTypes.objectOf(PropTypes.number),</span><br><span class=\"line\"></span><br><span class=\"line\">  // An object taking on a particular shape</span><br><span class=\"line\">  optionalObjectWithShape: PropTypes.shape(&#123;</span><br><span class=\"line\">    color: PropTypes.string,</span><br><span class=\"line\">    fontSize: PropTypes.number</span><br><span class=\"line\">  &#125;),</span><br><span class=\"line\"></span><br><span class=\"line\">  // You can chain any of the above with `isRequired` to make sure a warning</span><br><span class=\"line\">  // is shown if the prop isn&apos;t provided.</span><br><span class=\"line\">  requiredFunc: PropTypes.func.isRequired,</span><br><span class=\"line\"></span><br><span class=\"line\">  // A value of any data type</span><br><span class=\"line\">  requiredAny: PropTypes.any.isRequired,</span><br><span class=\"line\"></span><br><span class=\"line\">  // You can also specify a custom validator. It should return an Error</span><br><span class=\"line\">  // object if the validation fails. Don&apos;t `console.warn` or throw, as this</span><br><span class=\"line\">  // won&apos;t work inside `oneOfType`.</span><br><span class=\"line\">  customProp: function(props, propName, componentName) &#123;</span><br><span class=\"line\">    if (!/matchme/.test(props[propName])) &#123;</span><br><span class=\"line\">      return new Error(</span><br><span class=\"line\">        &apos;Invalid prop `&apos; + propName + &apos;` supplied to&apos; +</span><br><span class=\"line\">        &apos; `&apos; + componentName + &apos;`. Validation failed.&apos;</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // You can also supply a custom validator to `arrayOf` and `objectOf`.</span><br><span class=\"line\">  // It should return an Error object if the validation fails. The validator</span><br><span class=\"line\">  // will be called for each key in the array or object. The first two</span><br><span class=\"line\">  // arguments of the validator are the array or object itself, and the</span><br><span class=\"line\">  // current item&apos;s key.</span><br><span class=\"line\">  customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) &#123;</span><br><span class=\"line\">    if (!/matchme/.test(propValue[key])) &#123;</span><br><span class=\"line\">      return new Error(</span><br><span class=\"line\">        &apos;Invalid prop `&apos; + propFullName + &apos;` supplied to&apos; +</span><br><span class=\"line\">        &apos; `&apos; + componentName + &apos;`. Validation failed.&apos;</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"'react基础'","date":"2018-05-09T09:39:55.000Z","_content":"\n\n[react官网](https://reactjs.org/docs/hello-world.html)\n\n## 组件\n#### 1. 无状态组件\n  - 在React中，组件的名字必须用大写字母开头，而包含该组件定义的文件名也应该是大写字母(便于区分，也可以不是)。\n  - 无状态组件是纯展示组件，仅仅只是用于数据的展示，只根据传入的props来进行展示，不涉及到state状态处理，通过函数式的方式来创建一个无状态函数式组件(大多数组件都是无状态组件，通过简单的组合可以构建成其他的组件，最后合并成一个大的应用)。\n  - 无状态函数式组件是一个只带有render方法的组件，通过函数形式或者箭头函数形式创建，该组件无state状态。\n\n```\nimport React from \"react\";\n\n//创建方式一,相当于es5的函数声明的方式创建\n function NoState (props) {\n     return (\n         <div>this is NoState Component</div>\n     )\n }\n```\n\n```\n//创建方式二,相当于es5的函数表达式的方式创建\nconst NoState = (props) => {\n    return (\n        <div>this is Nostate Component</div>\n    )\n}\n\nexport default NoState\n```\n--------------------------------------------------------------------------------\n- 无状态函数式组件没有组件实例化的过程，成为一个render方法的函数来执行，减少分配的内存，使整体渲染性能得到提高，因此展示数据的组件优先选择这种方式。\n- 无状态组件没有实例化得过程，因此无法访问组件this中的对象\n- 无状态组件不需要组件生命周期管理和状态管理，底层在实现这种形式的组件的时候不会实现组件的生命周期方法，所以无状态组件不能参与组件生命周期管理\n- 无状态组件只能访问传入的props，同样的props会得到同样的渲染结果\n\n<!-- more -->\n\n当我们的组件开始有逻辑处理，之前的那种方式胜任不了时索要采取的一种形式，通过继承react的Component对象而来\n代码的render方法，则是Component中，专门提供的用来处理jsx模板的方法。\n第一种方式不同的是，我们接收传入进来的参数，使用的是this.props，第一种方式将props放置于函数参数中，而这种方式则是将props挂载与实例对象上，因此会有所不同\n```\n// helloWorld.jsx\nimport React, {Component} from 'react';\nclass HelloWorld extends Component {\n    clickHander = () => {\n        console.log(this.props);\n        console.log(this.props.name);\n    }\n\n    render() {\n        return (\n            <div onClick={this.clickHander}>{ this.props.name } say: Hello World!</div>\n        )\n    }\n}\nexport default HelloWorld;\n```\n\n\n## 组件之间的交互\n#### 父组件与子组件之间的交互\n1. 父组件修改子组件，只需要修改传入的props属性\n2. 子组件修改父组件，需要父组件向子组件传递一个函数，该函数在父组件中定义，在子组件中触发执行\n子组件与子组件之间的交互\n3. 通过影响共同的父组件来进行交互\n\n\n\n```\nstate = {\n    switch: 0,\n    name: this.props.name1\n}\nclickHander = () => {\n    const {name1, name2} = this.props;\n    if (this.state.switch === 0) {\n        this.setState({\n            switch: 1,\n            name: name2\n        })\n    } else {\n        this.setState({\n            switch: 0,\n            name: name1\n        })\n    }\n};\nrender() {\n    return (\n        <div onClick={this.clickHander}>hello world !{this.state.name}</div>\n    )\n}\n```\n\n先来说说state相关的基础知识。首先了解ES6 class语法的同学都应该知道，当我们通过这种方式来写的时候，其实是将state写入了构造函数之中。\n\nstate = {} // 等同于ES5构造函数中的this.state = {}\n在对象中，我们可以通过this.state的方式来访问state中所存储的属性\nsetState接收一个对象，它的运行结果类似于执行一次assign方法。会修改传入的属性，而其他的属性则保持不变\nreact赋予state的特性，则是当state被修改时，会引起组件的一次重新渲染。即render方法会重新执行一次。也正是由于这个特性，因此当我们想要改变界面上的元素内容时，常常只需要改变state中的值就行了\n而setState也有一个非常重要的特性，那就是，该方法是异步的。它并不会立即执行，而会在下一轮事件循环中执行\n// 假设state.name的初始值为Tom，我们改变它的值this.setState({    name: 'Jason'})// 然后立即查看它的值console.log(this.state.name) // 仍然为Tom，不会立即改变\n\n### refs\nreact组件其实是虚拟DOM，因此通常我们需要通过特殊的方式才能拿到真正的DOM元素。大概说一说虚拟DOM是个什么形式存在的，它其实就是通过js对象的方式将DOM元素相关的都存储其实，比如一个div元素可能会是这样\n```\n// 当然可能命名会是其他的，大概表达一个意思，不深究哈\n{\n    nodeName: 'div',\n    className: 'hello-world',\n    style: {},\n    parentNodes: 'root',\n    childrenNodes: []\n    ...\n}\n```\n\n而我们想要拿到真实的DOM元素，react中提供了一种叫做ref的属性来实现这个目的\n```\nimport React, { Component } from 'react';\nclass HelloWorld extends Component {\n    clickHander = () => {\n        console.log(this.refs)\n    } \n    render () {\n        return (\n            <div className=\"container\" onClick={this.clickHander}>\n                <div ref=\"hello\" className=\"hello\">Hello</div>\n                <div ref=\"world\" className=\"world\">World</div>\n            </div>\n        )\n    }\n}\nexport default HelloWorld;\n```\n为了区分ES6语法中的class关键字，当我们在jsx中给元素添加class时，需要使用className来代替\n我们在jsx中，可以给元素添加ref属性，而这些拥有ref属性的元素，会统一放在组件对象的refs中，因此，当我们想要访问对应的真实DOM时，则通过this.refs来访问即可。\n当然，ref的值不仅仅可以为一个名字，同时还可以为一个回调函数，这个函数会在render渲染时执行，也就是说，每当render函数执行一次，ref的回调函数也会执行一次。\n```\n// src/helloWorld.jsx\nimport React, { Component } from 'react';class HelloWorld extends Component {\n    clickHander = () => {\n        console.log(this.refs)\n    } refCallback = (elem) => {\n        console.log(elem);\n    } render () {\n        return (\n            <div className=\"container\" onClick={this.clickHander}>\n                <div ref=\"hello\" className=\"hello\">Hello</div>\n                <div ref={this.refCallback} className=\"world\">World</div>\n            </div>\n        )\n    }\n}export default HelloWorld;\n```\n\n\n### 组件生命周期\n件的生命周期，指的就是一个组件，从创建到销毁的这样一个过程，react为组件的生命周期提供了很多的钩子函数\n\n##### react组件有三种状态：\n- Mounted：已经插入真实DOM\n- Updating：正在被重新渲染\n- Unmounted：已移出真实DOM\n- \n##### 每个状态的处理函数\n- will：函数在进入状态之前调用\n- did：函数在进入状态之后调用\n\n##### 组件第一次渲染完成的前后时刻，所谓的渲染完成，即组件已经被渲染成为真实DOM并插入到了html之中\n  - componentWillMount 在首次渲染完成之前，此时可修改组件的state\n  - componentDidMount 真实DOM渲染完成之后，该方法可通过this.getDOMNode()访问到真实的DOM元素，可以使用其他的类库来操作这个DOM\n\n##### 组件属性(我们前面提到的props与state)更新的前后时刻\n  - componentWillUpdate 接收到一个新的state或者props时，在重新render之前调用，此时不允许更新props和state\n  - componentDidUpdate 组件完成更新之后调用，此时可访问新的DOM元素\n\n###### 组件取消挂载之前(取消之后就没必要提供钩子函数了)\n`componentWillUnmount`\n\n###### 两个特殊的处理函数\n  - `componentWillReceiveProps(object nextProps)`：组件接收到新的props时，在重新render之前调用,此时可以更改props和state。首先props发生改变->然后componentWillReceiveProps去判断是否需要重新渲染(`shouldComponentUpdate`)->如果不需要则继续running->如果需要则执行`componentWillUpdate`->渲染DOM树之后执行`componentDidUpdate`->进入running\n  - `shouldComponentUpdate(nextProps, nextState)`(更新发生前立即被调用) 接收到一个新的state或者props时，在重新render之前调用，组件判断是否重新render前调用。首先state发生改变->判断是否需要重新渲染新的props和state(`shouldComponentUpdate`) -> 根据判断决定执行render过程还是继续·保持running状态\n\n###### 三个统一调用的方法,用于组件初始化，获取默认属性和状态\n  - getDefaultProps：作用于组件类，只调用一次，返回对象用于设置默认的props，对于引用值，会在实例中共享\n  - getInitialState：作用于组件的实例，在实例创建时只调用一次，，用于初始化没个实例的state，可访问this.props\n  - render：必选的方法，创建vistual DOM （1. 只能通过this.props和this.state访问数据 2. 可以返回null、false或任何React组件 3. 只能出现一个顶级组件（不能返回数组）4.不能改变组件的状态 5. 不能修改DOM的输出\n\n###### 已挂载的方法\n  - component.forceUpdate() 可以在任何已经挂载的组件上使用，当你知道某些深处的组件状态未通过this.setState而改变了的时候\n\n\n\n>componentDidMount，组件第一次渲染完成之后调用的componentDidMount，既然是组件第一次渲染完成之后才会调用，也就是说，该函数在react组件的生命周期中，只会调用一次。而渲染完成，则表示组件已经被渲染成为真实DOM插入了html中。所以这时候就可以通过ref获取真实元素。在实际开发中，常常需要通过ajax获取数据，而数据请求的这个行为，则最适合放在componentDidMount中来执行。通常会在首次渲染改变组件状态(state)的行为，或者称之为有副作用的行为，都建议放在componentDidMount中来执行。主要是因为state的改动会引发组件的重新渲染。\n\n\n![image](http://images2017.cnblogs.com/blog/1106982/201708/1106982-20170811224737742-1564011484.jpg)\n\n## PropTypes\n```\nimport PropTypes from 'prop-types';\n\nMyComponent.propTypes = {\n  // You can declare that a prop is a specific JS primitive. By default, these\n  // are all optional.\n  optionalArray: PropTypes.array,\n  optionalBool: PropTypes.bool,\n  optionalFunc: PropTypes.func,\n  optionalNumber: PropTypes.number,\n  optionalObject: PropTypes.object,\n  optionalString: PropTypes.string,\n  optionalSymbol: PropTypes.symbol,\n\n  // Anything that can be rendered: numbers, strings, elements or an array\n  // (or fragment) containing these types.\n  optionalNode: PropTypes.node,\n\n  // A React element.\n  optionalElement: PropTypes.element,\n\n  // You can also declare that a prop is an instance of a class. This uses\n  // JS's instanceof operator.\n  optionalMessage: PropTypes.instanceOf(Message),\n\n  // You can ensure that your prop is limited to specific values by treating\n  // it as an enum.\n  optionalEnum: PropTypes.oneOf(['News', 'Photos']),\n\n  // An object that could be one of many types\n  optionalUnion: PropTypes.oneOfType([\n    PropTypes.string,\n    PropTypes.number,\n    PropTypes.instanceOf(Message)\n  ]),\n\n  // An array of a certain type\n  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),\n\n  // An object with property values of a certain type\n  optionalObjectOf: PropTypes.objectOf(PropTypes.number),\n\n  // An object taking on a particular shape\n  optionalObjectWithShape: PropTypes.shape({\n    color: PropTypes.string,\n    fontSize: PropTypes.number\n  }),\n\n  // You can chain any of the above with `isRequired` to make sure a warning\n  // is shown if the prop isn't provided.\n  requiredFunc: PropTypes.func.isRequired,\n\n  // A value of any data type\n  requiredAny: PropTypes.any.isRequired,\n\n  // You can also specify a custom validator. It should return an Error\n  // object if the validation fails. Don't `console.warn` or throw, as this\n  // won't work inside `oneOfType`.\n  customProp: function(props, propName, componentName) {\n    if (!/matchme/.test(props[propName])) {\n      return new Error(\n        'Invalid prop `' + propName + '` supplied to' +\n        ' `' + componentName + '`. Validation failed.'\n      );\n    }\n  },\n\n  // You can also supply a custom validator to `arrayOf` and `objectOf`.\n  // It should return an Error object if the validation fails. The validator\n  // will be called for each key in the array or object. The first two\n  // arguments of the validator are the array or object itself, and the\n  // current item's key.\n  customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) {\n    if (!/matchme/.test(propValue[key])) {\n      return new Error(\n        'Invalid prop `' + propFullName + '` supplied to' +\n        ' `' + componentName + '`. Validation failed.'\n      );\n    }\n  })\n};\n```\n\n\t","source":"_posts/react基础.md","raw":"---\ntitle: '''react基础'''\ndate: 2018-05-09 17:39:55\ntags: react\n---\n\n\n[react官网](https://reactjs.org/docs/hello-world.html)\n\n## 组件\n#### 1. 无状态组件\n  - 在React中，组件的名字必须用大写字母开头，而包含该组件定义的文件名也应该是大写字母(便于区分，也可以不是)。\n  - 无状态组件是纯展示组件，仅仅只是用于数据的展示，只根据传入的props来进行展示，不涉及到state状态处理，通过函数式的方式来创建一个无状态函数式组件(大多数组件都是无状态组件，通过简单的组合可以构建成其他的组件，最后合并成一个大的应用)。\n  - 无状态函数式组件是一个只带有render方法的组件，通过函数形式或者箭头函数形式创建，该组件无state状态。\n\n```\nimport React from \"react\";\n\n//创建方式一,相当于es5的函数声明的方式创建\n function NoState (props) {\n     return (\n         <div>this is NoState Component</div>\n     )\n }\n```\n\n```\n//创建方式二,相当于es5的函数表达式的方式创建\nconst NoState = (props) => {\n    return (\n        <div>this is Nostate Component</div>\n    )\n}\n\nexport default NoState\n```\n--------------------------------------------------------------------------------\n- 无状态函数式组件没有组件实例化的过程，成为一个render方法的函数来执行，减少分配的内存，使整体渲染性能得到提高，因此展示数据的组件优先选择这种方式。\n- 无状态组件没有实例化得过程，因此无法访问组件this中的对象\n- 无状态组件不需要组件生命周期管理和状态管理，底层在实现这种形式的组件的时候不会实现组件的生命周期方法，所以无状态组件不能参与组件生命周期管理\n- 无状态组件只能访问传入的props，同样的props会得到同样的渲染结果\n\n<!-- more -->\n\n当我们的组件开始有逻辑处理，之前的那种方式胜任不了时索要采取的一种形式，通过继承react的Component对象而来\n代码的render方法，则是Component中，专门提供的用来处理jsx模板的方法。\n第一种方式不同的是，我们接收传入进来的参数，使用的是this.props，第一种方式将props放置于函数参数中，而这种方式则是将props挂载与实例对象上，因此会有所不同\n```\n// helloWorld.jsx\nimport React, {Component} from 'react';\nclass HelloWorld extends Component {\n    clickHander = () => {\n        console.log(this.props);\n        console.log(this.props.name);\n    }\n\n    render() {\n        return (\n            <div onClick={this.clickHander}>{ this.props.name } say: Hello World!</div>\n        )\n    }\n}\nexport default HelloWorld;\n```\n\n\n## 组件之间的交互\n#### 父组件与子组件之间的交互\n1. 父组件修改子组件，只需要修改传入的props属性\n2. 子组件修改父组件，需要父组件向子组件传递一个函数，该函数在父组件中定义，在子组件中触发执行\n子组件与子组件之间的交互\n3. 通过影响共同的父组件来进行交互\n\n\n\n```\nstate = {\n    switch: 0,\n    name: this.props.name1\n}\nclickHander = () => {\n    const {name1, name2} = this.props;\n    if (this.state.switch === 0) {\n        this.setState({\n            switch: 1,\n            name: name2\n        })\n    } else {\n        this.setState({\n            switch: 0,\n            name: name1\n        })\n    }\n};\nrender() {\n    return (\n        <div onClick={this.clickHander}>hello world !{this.state.name}</div>\n    )\n}\n```\n\n先来说说state相关的基础知识。首先了解ES6 class语法的同学都应该知道，当我们通过这种方式来写的时候，其实是将state写入了构造函数之中。\n\nstate = {} // 等同于ES5构造函数中的this.state = {}\n在对象中，我们可以通过this.state的方式来访问state中所存储的属性\nsetState接收一个对象，它的运行结果类似于执行一次assign方法。会修改传入的属性，而其他的属性则保持不变\nreact赋予state的特性，则是当state被修改时，会引起组件的一次重新渲染。即render方法会重新执行一次。也正是由于这个特性，因此当我们想要改变界面上的元素内容时，常常只需要改变state中的值就行了\n而setState也有一个非常重要的特性，那就是，该方法是异步的。它并不会立即执行，而会在下一轮事件循环中执行\n// 假设state.name的初始值为Tom，我们改变它的值this.setState({    name: 'Jason'})// 然后立即查看它的值console.log(this.state.name) // 仍然为Tom，不会立即改变\n\n### refs\nreact组件其实是虚拟DOM，因此通常我们需要通过特殊的方式才能拿到真正的DOM元素。大概说一说虚拟DOM是个什么形式存在的，它其实就是通过js对象的方式将DOM元素相关的都存储其实，比如一个div元素可能会是这样\n```\n// 当然可能命名会是其他的，大概表达一个意思，不深究哈\n{\n    nodeName: 'div',\n    className: 'hello-world',\n    style: {},\n    parentNodes: 'root',\n    childrenNodes: []\n    ...\n}\n```\n\n而我们想要拿到真实的DOM元素，react中提供了一种叫做ref的属性来实现这个目的\n```\nimport React, { Component } from 'react';\nclass HelloWorld extends Component {\n    clickHander = () => {\n        console.log(this.refs)\n    } \n    render () {\n        return (\n            <div className=\"container\" onClick={this.clickHander}>\n                <div ref=\"hello\" className=\"hello\">Hello</div>\n                <div ref=\"world\" className=\"world\">World</div>\n            </div>\n        )\n    }\n}\nexport default HelloWorld;\n```\n为了区分ES6语法中的class关键字，当我们在jsx中给元素添加class时，需要使用className来代替\n我们在jsx中，可以给元素添加ref属性，而这些拥有ref属性的元素，会统一放在组件对象的refs中，因此，当我们想要访问对应的真实DOM时，则通过this.refs来访问即可。\n当然，ref的值不仅仅可以为一个名字，同时还可以为一个回调函数，这个函数会在render渲染时执行，也就是说，每当render函数执行一次，ref的回调函数也会执行一次。\n```\n// src/helloWorld.jsx\nimport React, { Component } from 'react';class HelloWorld extends Component {\n    clickHander = () => {\n        console.log(this.refs)\n    } refCallback = (elem) => {\n        console.log(elem);\n    } render () {\n        return (\n            <div className=\"container\" onClick={this.clickHander}>\n                <div ref=\"hello\" className=\"hello\">Hello</div>\n                <div ref={this.refCallback} className=\"world\">World</div>\n            </div>\n        )\n    }\n}export default HelloWorld;\n```\n\n\n### 组件生命周期\n件的生命周期，指的就是一个组件，从创建到销毁的这样一个过程，react为组件的生命周期提供了很多的钩子函数\n\n##### react组件有三种状态：\n- Mounted：已经插入真实DOM\n- Updating：正在被重新渲染\n- Unmounted：已移出真实DOM\n- \n##### 每个状态的处理函数\n- will：函数在进入状态之前调用\n- did：函数在进入状态之后调用\n\n##### 组件第一次渲染完成的前后时刻，所谓的渲染完成，即组件已经被渲染成为真实DOM并插入到了html之中\n  - componentWillMount 在首次渲染完成之前，此时可修改组件的state\n  - componentDidMount 真实DOM渲染完成之后，该方法可通过this.getDOMNode()访问到真实的DOM元素，可以使用其他的类库来操作这个DOM\n\n##### 组件属性(我们前面提到的props与state)更新的前后时刻\n  - componentWillUpdate 接收到一个新的state或者props时，在重新render之前调用，此时不允许更新props和state\n  - componentDidUpdate 组件完成更新之后调用，此时可访问新的DOM元素\n\n###### 组件取消挂载之前(取消之后就没必要提供钩子函数了)\n`componentWillUnmount`\n\n###### 两个特殊的处理函数\n  - `componentWillReceiveProps(object nextProps)`：组件接收到新的props时，在重新render之前调用,此时可以更改props和state。首先props发生改变->然后componentWillReceiveProps去判断是否需要重新渲染(`shouldComponentUpdate`)->如果不需要则继续running->如果需要则执行`componentWillUpdate`->渲染DOM树之后执行`componentDidUpdate`->进入running\n  - `shouldComponentUpdate(nextProps, nextState)`(更新发生前立即被调用) 接收到一个新的state或者props时，在重新render之前调用，组件判断是否重新render前调用。首先state发生改变->判断是否需要重新渲染新的props和state(`shouldComponentUpdate`) -> 根据判断决定执行render过程还是继续·保持running状态\n\n###### 三个统一调用的方法,用于组件初始化，获取默认属性和状态\n  - getDefaultProps：作用于组件类，只调用一次，返回对象用于设置默认的props，对于引用值，会在实例中共享\n  - getInitialState：作用于组件的实例，在实例创建时只调用一次，，用于初始化没个实例的state，可访问this.props\n  - render：必选的方法，创建vistual DOM （1. 只能通过this.props和this.state访问数据 2. 可以返回null、false或任何React组件 3. 只能出现一个顶级组件（不能返回数组）4.不能改变组件的状态 5. 不能修改DOM的输出\n\n###### 已挂载的方法\n  - component.forceUpdate() 可以在任何已经挂载的组件上使用，当你知道某些深处的组件状态未通过this.setState而改变了的时候\n\n\n\n>componentDidMount，组件第一次渲染完成之后调用的componentDidMount，既然是组件第一次渲染完成之后才会调用，也就是说，该函数在react组件的生命周期中，只会调用一次。而渲染完成，则表示组件已经被渲染成为真实DOM插入了html中。所以这时候就可以通过ref获取真实元素。在实际开发中，常常需要通过ajax获取数据，而数据请求的这个行为，则最适合放在componentDidMount中来执行。通常会在首次渲染改变组件状态(state)的行为，或者称之为有副作用的行为，都建议放在componentDidMount中来执行。主要是因为state的改动会引发组件的重新渲染。\n\n\n![image](http://images2017.cnblogs.com/blog/1106982/201708/1106982-20170811224737742-1564011484.jpg)\n\n## PropTypes\n```\nimport PropTypes from 'prop-types';\n\nMyComponent.propTypes = {\n  // You can declare that a prop is a specific JS primitive. By default, these\n  // are all optional.\n  optionalArray: PropTypes.array,\n  optionalBool: PropTypes.bool,\n  optionalFunc: PropTypes.func,\n  optionalNumber: PropTypes.number,\n  optionalObject: PropTypes.object,\n  optionalString: PropTypes.string,\n  optionalSymbol: PropTypes.symbol,\n\n  // Anything that can be rendered: numbers, strings, elements or an array\n  // (or fragment) containing these types.\n  optionalNode: PropTypes.node,\n\n  // A React element.\n  optionalElement: PropTypes.element,\n\n  // You can also declare that a prop is an instance of a class. This uses\n  // JS's instanceof operator.\n  optionalMessage: PropTypes.instanceOf(Message),\n\n  // You can ensure that your prop is limited to specific values by treating\n  // it as an enum.\n  optionalEnum: PropTypes.oneOf(['News', 'Photos']),\n\n  // An object that could be one of many types\n  optionalUnion: PropTypes.oneOfType([\n    PropTypes.string,\n    PropTypes.number,\n    PropTypes.instanceOf(Message)\n  ]),\n\n  // An array of a certain type\n  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),\n\n  // An object with property values of a certain type\n  optionalObjectOf: PropTypes.objectOf(PropTypes.number),\n\n  // An object taking on a particular shape\n  optionalObjectWithShape: PropTypes.shape({\n    color: PropTypes.string,\n    fontSize: PropTypes.number\n  }),\n\n  // You can chain any of the above with `isRequired` to make sure a warning\n  // is shown if the prop isn't provided.\n  requiredFunc: PropTypes.func.isRequired,\n\n  // A value of any data type\n  requiredAny: PropTypes.any.isRequired,\n\n  // You can also specify a custom validator. It should return an Error\n  // object if the validation fails. Don't `console.warn` or throw, as this\n  // won't work inside `oneOfType`.\n  customProp: function(props, propName, componentName) {\n    if (!/matchme/.test(props[propName])) {\n      return new Error(\n        'Invalid prop `' + propName + '` supplied to' +\n        ' `' + componentName + '`. Validation failed.'\n      );\n    }\n  },\n\n  // You can also supply a custom validator to `arrayOf` and `objectOf`.\n  // It should return an Error object if the validation fails. The validator\n  // will be called for each key in the array or object. The first two\n  // arguments of the validator are the array or object itself, and the\n  // current item's key.\n  customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) {\n    if (!/matchme/.test(propValue[key])) {\n      return new Error(\n        'Invalid prop `' + propFullName + '` supplied to' +\n        ' `' + componentName + '`. Validation failed.'\n      );\n    }\n  })\n};\n```\n\n\t","slug":"react基础","published":1,"updated":"2018-05-14T10:53:40.711Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjhag1ytn0006i0v6kn7uf0r5","content":"<p><a href=\"https://reactjs.org/docs/hello-world.html\" target=\"_blank\" rel=\"noopener\">react官网</a></p>\n<h2 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h2><h4 id=\"1-无状态组件\"><a href=\"#1-无状态组件\" class=\"headerlink\" title=\"1. 无状态组件\"></a>1. 无状态组件</h4><ul>\n<li>在React中，组件的名字必须用大写字母开头，而包含该组件定义的文件名也应该是大写字母(便于区分，也可以不是)。</li>\n<li>无状态组件是纯展示组件，仅仅只是用于数据的展示，只根据传入的props来进行展示，不涉及到state状态处理，通过函数式的方式来创建一个无状态函数式组件(大多数组件都是无状态组件，通过简单的组合可以构建成其他的组件，最后合并成一个大的应用)。</li>\n<li>无状态函数式组件是一个只带有render方法的组件，通过函数形式或者箭头函数形式创建，该组件无state状态。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React from &quot;react&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">//创建方式一,相当于es5的函数声明的方式创建</span><br><span class=\"line\"> function NoState (props) &#123;</span><br><span class=\"line\">     return (</span><br><span class=\"line\">         &lt;div&gt;this is NoState Component&lt;/div&gt;</span><br><span class=\"line\">     )</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//创建方式二,相当于es5的函数表达式的方式创建</span><br><span class=\"line\">const NoState = (props) =&gt; &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">        &lt;div&gt;this is Nostate Component&lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default NoState</span><br></pre></td></tr></table></figure>\n<hr>\n<ul>\n<li>无状态函数式组件没有组件实例化的过程，成为一个render方法的函数来执行，减少分配的内存，使整体渲染性能得到提高，因此展示数据的组件优先选择这种方式。</li>\n<li>无状态组件没有实例化得过程，因此无法访问组件this中的对象</li>\n<li>无状态组件不需要组件生命周期管理和状态管理，底层在实现这种形式的组件的时候不会实现组件的生命周期方法，所以无状态组件不能参与组件生命周期管理</li>\n<li>无状态组件只能访问传入的props，同样的props会得到同样的渲染结果</li>\n</ul>\n<a id=\"more\"></a>\n<p>当我们的组件开始有逻辑处理，之前的那种方式胜任不了时索要采取的一种形式，通过继承react的Component对象而来<br>代码的render方法，则是Component中，专门提供的用来处理jsx模板的方法。<br>第一种方式不同的是，我们接收传入进来的参数，使用的是this.props，第一种方式将props放置于函数参数中，而这种方式则是将props挂载与实例对象上，因此会有所不同<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// helloWorld.jsx</span><br><span class=\"line\">import React, &#123;Component&#125; from &apos;react&apos;;</span><br><span class=\"line\">class HelloWorld extends Component &#123;</span><br><span class=\"line\">    clickHander = () =&gt; &#123;</span><br><span class=\"line\">        console.log(this.props);</span><br><span class=\"line\">        console.log(this.props.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;div onClick=&#123;this.clickHander&#125;&gt;&#123; this.props.name &#125; say: Hello World!&lt;/div&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export default HelloWorld;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"组件之间的交互\"><a href=\"#组件之间的交互\" class=\"headerlink\" title=\"组件之间的交互\"></a>组件之间的交互</h2><h4 id=\"父组件与子组件之间的交互\"><a href=\"#父组件与子组件之间的交互\" class=\"headerlink\" title=\"父组件与子组件之间的交互\"></a>父组件与子组件之间的交互</h4><ol>\n<li>父组件修改子组件，只需要修改传入的props属性</li>\n<li>子组件修改父组件，需要父组件向子组件传递一个函数，该函数在父组件中定义，在子组件中触发执行<br>子组件与子组件之间的交互</li>\n<li>通过影响共同的父组件来进行交互</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">state = &#123;</span><br><span class=\"line\">    switch: 0,</span><br><span class=\"line\">    name: this.props.name1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">clickHander = () =&gt; &#123;</span><br><span class=\"line\">    const &#123;name1, name2&#125; = this.props;</span><br><span class=\"line\">    if (this.state.switch === 0) &#123;</span><br><span class=\"line\">        this.setState(&#123;</span><br><span class=\"line\">            switch: 1,</span><br><span class=\"line\">            name: name2</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        this.setState(&#123;</span><br><span class=\"line\">            switch: 0,</span><br><span class=\"line\">            name: name1</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">render() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">        &lt;div onClick=&#123;this.clickHander&#125;&gt;hello world !&#123;this.state.name&#125;&lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>先来说说state相关的基础知识。首先了解ES6 class语法的同学都应该知道，当我们通过这种方式来写的时候，其实是将state写入了构造函数之中。</p>\n<p>state = {} // 等同于ES5构造函数中的this.state = {}<br>在对象中，我们可以通过this.state的方式来访问state中所存储的属性<br>setState接收一个对象，它的运行结果类似于执行一次assign方法。会修改传入的属性，而其他的属性则保持不变<br>react赋予state的特性，则是当state被修改时，会引起组件的一次重新渲染。即render方法会重新执行一次。也正是由于这个特性，因此当我们想要改变界面上的元素内容时，常常只需要改变state中的值就行了<br>而setState也有一个非常重要的特性，那就是，该方法是异步的。它并不会立即执行，而会在下一轮事件循环中执行<br>// 假设state.name的初始值为Tom，我们改变它的值this.setState({    name: ‘Jason’})// 然后立即查看它的值console.log(this.state.name) // 仍然为Tom，不会立即改变</p>\n<h3 id=\"refs\"><a href=\"#refs\" class=\"headerlink\" title=\"refs\"></a>refs</h3><p>react组件其实是虚拟DOM，因此通常我们需要通过特殊的方式才能拿到真正的DOM元素。大概说一说虚拟DOM是个什么形式存在的，它其实就是通过js对象的方式将DOM元素相关的都存储其实，比如一个div元素可能会是这样<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 当然可能命名会是其他的，大概表达一个意思，不深究哈</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    nodeName: &apos;div&apos;,</span><br><span class=\"line\">    className: &apos;hello-world&apos;,</span><br><span class=\"line\">    style: &#123;&#125;,</span><br><span class=\"line\">    parentNodes: &apos;root&apos;,</span><br><span class=\"line\">    childrenNodes: []</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>而我们想要拿到真实的DOM元素，react中提供了一种叫做ref的属性来实现这个目的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class=\"line\">class HelloWorld extends Component &#123;</span><br><span class=\"line\">    clickHander = () =&gt; &#123;</span><br><span class=\"line\">        console.log(this.refs)</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    render () &#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;div className=&quot;container&quot; onClick=&#123;this.clickHander&#125;&gt;</span><br><span class=\"line\">                &lt;div ref=&quot;hello&quot; className=&quot;hello&quot;&gt;Hello&lt;/div&gt;</span><br><span class=\"line\">                &lt;div ref=&quot;world&quot; className=&quot;world&quot;&gt;World&lt;/div&gt;</span><br><span class=\"line\">            &lt;/div&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export default HelloWorld;</span><br></pre></td></tr></table></figure></p>\n<p>为了区分ES6语法中的class关键字，当我们在jsx中给元素添加class时，需要使用className来代替<br>我们在jsx中，可以给元素添加ref属性，而这些拥有ref属性的元素，会统一放在组件对象的refs中，因此，当我们想要访问对应的真实DOM时，则通过this.refs来访问即可。<br>当然，ref的值不仅仅可以为一个名字，同时还可以为一个回调函数，这个函数会在render渲染时执行，也就是说，每当render函数执行一次，ref的回调函数也会执行一次。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// src/helloWorld.jsx</span><br><span class=\"line\">import React, &#123; Component &#125; from &apos;react&apos;;class HelloWorld extends Component &#123;</span><br><span class=\"line\">    clickHander = () =&gt; &#123;</span><br><span class=\"line\">        console.log(this.refs)</span><br><span class=\"line\">    &#125; refCallback = (elem) =&gt; &#123;</span><br><span class=\"line\">        console.log(elem);</span><br><span class=\"line\">    &#125; render () &#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;div className=&quot;container&quot; onClick=&#123;this.clickHander&#125;&gt;</span><br><span class=\"line\">                &lt;div ref=&quot;hello&quot; className=&quot;hello&quot;&gt;Hello&lt;/div&gt;</span><br><span class=\"line\">                &lt;div ref=&#123;this.refCallback&#125; className=&quot;world&quot;&gt;World&lt;/div&gt;</span><br><span class=\"line\">            &lt;/div&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;export default HelloWorld;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"组件生命周期\"><a href=\"#组件生命周期\" class=\"headerlink\" title=\"组件生命周期\"></a>组件生命周期</h3><p>件的生命周期，指的就是一个组件，从创建到销毁的这样一个过程，react为组件的生命周期提供了很多的钩子函数</p>\n<h5 id=\"react组件有三种状态：\"><a href=\"#react组件有三种状态：\" class=\"headerlink\" title=\"react组件有三种状态：\"></a>react组件有三种状态：</h5><ul>\n<li>Mounted：已经插入真实DOM</li>\n<li>Updating：正在被重新渲染</li>\n<li>Unmounted：已移出真实DOM</li>\n<li><h5 id=\"每个状态的处理函数\"><a href=\"#每个状态的处理函数\" class=\"headerlink\" title=\"每个状态的处理函数\"></a>每个状态的处理函数</h5></li>\n<li>will：函数在进入状态之前调用</li>\n<li>did：函数在进入状态之后调用</li>\n</ul>\n<h5 id=\"组件第一次渲染完成的前后时刻，所谓的渲染完成，即组件已经被渲染成为真实DOM并插入到了html之中\"><a href=\"#组件第一次渲染完成的前后时刻，所谓的渲染完成，即组件已经被渲染成为真实DOM并插入到了html之中\" class=\"headerlink\" title=\"组件第一次渲染完成的前后时刻，所谓的渲染完成，即组件已经被渲染成为真实DOM并插入到了html之中\"></a>组件第一次渲染完成的前后时刻，所谓的渲染完成，即组件已经被渲染成为真实DOM并插入到了html之中</h5><ul>\n<li>componentWillMount 在首次渲染完成之前，此时可修改组件的state</li>\n<li>componentDidMount 真实DOM渲染完成之后，该方法可通过this.getDOMNode()访问到真实的DOM元素，可以使用其他的类库来操作这个DOM</li>\n</ul>\n<h5 id=\"组件属性-我们前面提到的props与state-更新的前后时刻\"><a href=\"#组件属性-我们前面提到的props与state-更新的前后时刻\" class=\"headerlink\" title=\"组件属性(我们前面提到的props与state)更新的前后时刻\"></a>组件属性(我们前面提到的props与state)更新的前后时刻</h5><ul>\n<li>componentWillUpdate 接收到一个新的state或者props时，在重新render之前调用，此时不允许更新props和state</li>\n<li>componentDidUpdate 组件完成更新之后调用，此时可访问新的DOM元素</li>\n</ul>\n<h6 id=\"组件取消挂载之前-取消之后就没必要提供钩子函数了\"><a href=\"#组件取消挂载之前-取消之后就没必要提供钩子函数了\" class=\"headerlink\" title=\"组件取消挂载之前(取消之后就没必要提供钩子函数了)\"></a>组件取消挂载之前(取消之后就没必要提供钩子函数了)</h6><p><code>componentWillUnmount</code></p>\n<h6 id=\"两个特殊的处理函数\"><a href=\"#两个特殊的处理函数\" class=\"headerlink\" title=\"两个特殊的处理函数\"></a>两个特殊的处理函数</h6><ul>\n<li><code>componentWillReceiveProps(object nextProps)</code>：组件接收到新的props时，在重新render之前调用,此时可以更改props和state。首先props发生改变-&gt;然后componentWillReceiveProps去判断是否需要重新渲染(<code>shouldComponentUpdate</code>)-&gt;如果不需要则继续running-&gt;如果需要则执行<code>componentWillUpdate</code>-&gt;渲染DOM树之后执行<code>componentDidUpdate</code>-&gt;进入running</li>\n<li><code>shouldComponentUpdate(nextProps, nextState)</code>(更新发生前立即被调用) 接收到一个新的state或者props时，在重新render之前调用，组件判断是否重新render前调用。首先state发生改变-&gt;判断是否需要重新渲染新的props和state(<code>shouldComponentUpdate</code>) -&gt; 根据判断决定执行render过程还是继续·保持running状态</li>\n</ul>\n<h6 id=\"三个统一调用的方法-用于组件初始化，获取默认属性和状态\"><a href=\"#三个统一调用的方法-用于组件初始化，获取默认属性和状态\" class=\"headerlink\" title=\"三个统一调用的方法,用于组件初始化，获取默认属性和状态\"></a>三个统一调用的方法,用于组件初始化，获取默认属性和状态</h6><ul>\n<li>getDefaultProps：作用于组件类，只调用一次，返回对象用于设置默认的props，对于引用值，会在实例中共享</li>\n<li>getInitialState：作用于组件的实例，在实例创建时只调用一次，，用于初始化没个实例的state，可访问this.props</li>\n<li>render：必选的方法，创建vistual DOM （1. 只能通过this.props和this.state访问数据 2. 可以返回null、false或任何React组件 3. 只能出现一个顶级组件（不能返回数组）4.不能改变组件的状态 5. 不能修改DOM的输出</li>\n</ul>\n<h6 id=\"已挂载的方法\"><a href=\"#已挂载的方法\" class=\"headerlink\" title=\"已挂载的方法\"></a>已挂载的方法</h6><ul>\n<li>component.forceUpdate() 可以在任何已经挂载的组件上使用，当你知道某些深处的组件状态未通过this.setState而改变了的时候</li>\n</ul>\n<blockquote>\n<p>componentDidMount，组件第一次渲染完成之后调用的componentDidMount，既然是组件第一次渲染完成之后才会调用，也就是说，该函数在react组件的生命周期中，只会调用一次。而渲染完成，则表示组件已经被渲染成为真实DOM插入了html中。所以这时候就可以通过ref获取真实元素。在实际开发中，常常需要通过ajax获取数据，而数据请求的这个行为，则最适合放在componentDidMount中来执行。通常会在首次渲染改变组件状态(state)的行为，或者称之为有副作用的行为，都建议放在componentDidMount中来执行。主要是因为state的改动会引发组件的重新渲染。</p>\n</blockquote>\n<p><img src=\"http://images2017.cnblogs.com/blog/1106982/201708/1106982-20170811224737742-1564011484.jpg\" alt=\"image\"></p>\n<h2 id=\"PropTypes\"><a href=\"#PropTypes\" class=\"headerlink\" title=\"PropTypes\"></a>PropTypes</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import PropTypes from &apos;prop-types&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">MyComponent.propTypes = &#123;</span><br><span class=\"line\">  // You can declare that a prop is a specific JS primitive. By default, these</span><br><span class=\"line\">  // are all optional.</span><br><span class=\"line\">  optionalArray: PropTypes.array,</span><br><span class=\"line\">  optionalBool: PropTypes.bool,</span><br><span class=\"line\">  optionalFunc: PropTypes.func,</span><br><span class=\"line\">  optionalNumber: PropTypes.number,</span><br><span class=\"line\">  optionalObject: PropTypes.object,</span><br><span class=\"line\">  optionalString: PropTypes.string,</span><br><span class=\"line\">  optionalSymbol: PropTypes.symbol,</span><br><span class=\"line\"></span><br><span class=\"line\">  // Anything that can be rendered: numbers, strings, elements or an array</span><br><span class=\"line\">  // (or fragment) containing these types.</span><br><span class=\"line\">  optionalNode: PropTypes.node,</span><br><span class=\"line\"></span><br><span class=\"line\">  // A React element.</span><br><span class=\"line\">  optionalElement: PropTypes.element,</span><br><span class=\"line\"></span><br><span class=\"line\">  // You can also declare that a prop is an instance of a class. This uses</span><br><span class=\"line\">  // JS&apos;s instanceof operator.</span><br><span class=\"line\">  optionalMessage: PropTypes.instanceOf(Message),</span><br><span class=\"line\"></span><br><span class=\"line\">  // You can ensure that your prop is limited to specific values by treating</span><br><span class=\"line\">  // it as an enum.</span><br><span class=\"line\">  optionalEnum: PropTypes.oneOf([&apos;News&apos;, &apos;Photos&apos;]),</span><br><span class=\"line\"></span><br><span class=\"line\">  // An object that could be one of many types</span><br><span class=\"line\">  optionalUnion: PropTypes.oneOfType([</span><br><span class=\"line\">    PropTypes.string,</span><br><span class=\"line\">    PropTypes.number,</span><br><span class=\"line\">    PropTypes.instanceOf(Message)</span><br><span class=\"line\">  ]),</span><br><span class=\"line\"></span><br><span class=\"line\">  // An array of a certain type</span><br><span class=\"line\">  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),</span><br><span class=\"line\"></span><br><span class=\"line\">  // An object with property values of a certain type</span><br><span class=\"line\">  optionalObjectOf: PropTypes.objectOf(PropTypes.number),</span><br><span class=\"line\"></span><br><span class=\"line\">  // An object taking on a particular shape</span><br><span class=\"line\">  optionalObjectWithShape: PropTypes.shape(&#123;</span><br><span class=\"line\">    color: PropTypes.string,</span><br><span class=\"line\">    fontSize: PropTypes.number</span><br><span class=\"line\">  &#125;),</span><br><span class=\"line\"></span><br><span class=\"line\">  // You can chain any of the above with `isRequired` to make sure a warning</span><br><span class=\"line\">  // is shown if the prop isn&apos;t provided.</span><br><span class=\"line\">  requiredFunc: PropTypes.func.isRequired,</span><br><span class=\"line\"></span><br><span class=\"line\">  // A value of any data type</span><br><span class=\"line\">  requiredAny: PropTypes.any.isRequired,</span><br><span class=\"line\"></span><br><span class=\"line\">  // You can also specify a custom validator. It should return an Error</span><br><span class=\"line\">  // object if the validation fails. Don&apos;t `console.warn` or throw, as this</span><br><span class=\"line\">  // won&apos;t work inside `oneOfType`.</span><br><span class=\"line\">  customProp: function(props, propName, componentName) &#123;</span><br><span class=\"line\">    if (!/matchme/.test(props[propName])) &#123;</span><br><span class=\"line\">      return new Error(</span><br><span class=\"line\">        &apos;Invalid prop `&apos; + propName + &apos;` supplied to&apos; +</span><br><span class=\"line\">        &apos; `&apos; + componentName + &apos;`. Validation failed.&apos;</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // You can also supply a custom validator to `arrayOf` and `objectOf`.</span><br><span class=\"line\">  // It should return an Error object if the validation fails. The validator</span><br><span class=\"line\">  // will be called for each key in the array or object. The first two</span><br><span class=\"line\">  // arguments of the validator are the array or object itself, and the</span><br><span class=\"line\">  // current item&apos;s key.</span><br><span class=\"line\">  customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) &#123;</span><br><span class=\"line\">    if (!/matchme/.test(propValue[key])) &#123;</span><br><span class=\"line\">      return new Error(</span><br><span class=\"line\">        &apos;Invalid prop `&apos; + propFullName + &apos;` supplied to&apos; +</span><br><span class=\"line\">        &apos; `&apos; + componentName + &apos;`. Validation failed.&apos;</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://reactjs.org/docs/hello-world.html\" target=\"_blank\" rel=\"noopener\">react官网</a></p>\n<h2 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h2><h4 id=\"1-无状态组件\"><a href=\"#1-无状态组件\" class=\"headerlink\" title=\"1. 无状态组件\"></a>1. 无状态组件</h4><ul>\n<li>在React中，组件的名字必须用大写字母开头，而包含该组件定义的文件名也应该是大写字母(便于区分，也可以不是)。</li>\n<li>无状态组件是纯展示组件，仅仅只是用于数据的展示，只根据传入的props来进行展示，不涉及到state状态处理，通过函数式的方式来创建一个无状态函数式组件(大多数组件都是无状态组件，通过简单的组合可以构建成其他的组件，最后合并成一个大的应用)。</li>\n<li>无状态函数式组件是一个只带有render方法的组件，通过函数形式或者箭头函数形式创建，该组件无state状态。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React from &quot;react&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">//创建方式一,相当于es5的函数声明的方式创建</span><br><span class=\"line\"> function NoState (props) &#123;</span><br><span class=\"line\">     return (</span><br><span class=\"line\">         &lt;div&gt;this is NoState Component&lt;/div&gt;</span><br><span class=\"line\">     )</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//创建方式二,相当于es5的函数表达式的方式创建</span><br><span class=\"line\">const NoState = (props) =&gt; &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">        &lt;div&gt;this is Nostate Component&lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default NoState</span><br></pre></td></tr></table></figure>\n<hr>\n<ul>\n<li>无状态函数式组件没有组件实例化的过程，成为一个render方法的函数来执行，减少分配的内存，使整体渲染性能得到提高，因此展示数据的组件优先选择这种方式。</li>\n<li>无状态组件没有实例化得过程，因此无法访问组件this中的对象</li>\n<li>无状态组件不需要组件生命周期管理和状态管理，底层在实现这种形式的组件的时候不会实现组件的生命周期方法，所以无状态组件不能参与组件生命周期管理</li>\n<li>无状态组件只能访问传入的props，同样的props会得到同样的渲染结果</li>\n</ul>","more":"<p>当我们的组件开始有逻辑处理，之前的那种方式胜任不了时索要采取的一种形式，通过继承react的Component对象而来<br>代码的render方法，则是Component中，专门提供的用来处理jsx模板的方法。<br>第一种方式不同的是，我们接收传入进来的参数，使用的是this.props，第一种方式将props放置于函数参数中，而这种方式则是将props挂载与实例对象上，因此会有所不同<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// helloWorld.jsx</span><br><span class=\"line\">import React, &#123;Component&#125; from &apos;react&apos;;</span><br><span class=\"line\">class HelloWorld extends Component &#123;</span><br><span class=\"line\">    clickHander = () =&gt; &#123;</span><br><span class=\"line\">        console.log(this.props);</span><br><span class=\"line\">        console.log(this.props.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;div onClick=&#123;this.clickHander&#125;&gt;&#123; this.props.name &#125; say: Hello World!&lt;/div&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export default HelloWorld;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"组件之间的交互\"><a href=\"#组件之间的交互\" class=\"headerlink\" title=\"组件之间的交互\"></a>组件之间的交互</h2><h4 id=\"父组件与子组件之间的交互\"><a href=\"#父组件与子组件之间的交互\" class=\"headerlink\" title=\"父组件与子组件之间的交互\"></a>父组件与子组件之间的交互</h4><ol>\n<li>父组件修改子组件，只需要修改传入的props属性</li>\n<li>子组件修改父组件，需要父组件向子组件传递一个函数，该函数在父组件中定义，在子组件中触发执行<br>子组件与子组件之间的交互</li>\n<li>通过影响共同的父组件来进行交互</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">state = &#123;</span><br><span class=\"line\">    switch: 0,</span><br><span class=\"line\">    name: this.props.name1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">clickHander = () =&gt; &#123;</span><br><span class=\"line\">    const &#123;name1, name2&#125; = this.props;</span><br><span class=\"line\">    if (this.state.switch === 0) &#123;</span><br><span class=\"line\">        this.setState(&#123;</span><br><span class=\"line\">            switch: 1,</span><br><span class=\"line\">            name: name2</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        this.setState(&#123;</span><br><span class=\"line\">            switch: 0,</span><br><span class=\"line\">            name: name1</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">render() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">        &lt;div onClick=&#123;this.clickHander&#125;&gt;hello world !&#123;this.state.name&#125;&lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>先来说说state相关的基础知识。首先了解ES6 class语法的同学都应该知道，当我们通过这种方式来写的时候，其实是将state写入了构造函数之中。</p>\n<p>state = {} // 等同于ES5构造函数中的this.state = {}<br>在对象中，我们可以通过this.state的方式来访问state中所存储的属性<br>setState接收一个对象，它的运行结果类似于执行一次assign方法。会修改传入的属性，而其他的属性则保持不变<br>react赋予state的特性，则是当state被修改时，会引起组件的一次重新渲染。即render方法会重新执行一次。也正是由于这个特性，因此当我们想要改变界面上的元素内容时，常常只需要改变state中的值就行了<br>而setState也有一个非常重要的特性，那就是，该方法是异步的。它并不会立即执行，而会在下一轮事件循环中执行<br>// 假设state.name的初始值为Tom，我们改变它的值this.setState({    name: ‘Jason’})// 然后立即查看它的值console.log(this.state.name) // 仍然为Tom，不会立即改变</p>\n<h3 id=\"refs\"><a href=\"#refs\" class=\"headerlink\" title=\"refs\"></a>refs</h3><p>react组件其实是虚拟DOM，因此通常我们需要通过特殊的方式才能拿到真正的DOM元素。大概说一说虚拟DOM是个什么形式存在的，它其实就是通过js对象的方式将DOM元素相关的都存储其实，比如一个div元素可能会是这样<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 当然可能命名会是其他的，大概表达一个意思，不深究哈</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    nodeName: &apos;div&apos;,</span><br><span class=\"line\">    className: &apos;hello-world&apos;,</span><br><span class=\"line\">    style: &#123;&#125;,</span><br><span class=\"line\">    parentNodes: &apos;root&apos;,</span><br><span class=\"line\">    childrenNodes: []</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>而我们想要拿到真实的DOM元素，react中提供了一种叫做ref的属性来实现这个目的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class=\"line\">class HelloWorld extends Component &#123;</span><br><span class=\"line\">    clickHander = () =&gt; &#123;</span><br><span class=\"line\">        console.log(this.refs)</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    render () &#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;div className=&quot;container&quot; onClick=&#123;this.clickHander&#125;&gt;</span><br><span class=\"line\">                &lt;div ref=&quot;hello&quot; className=&quot;hello&quot;&gt;Hello&lt;/div&gt;</span><br><span class=\"line\">                &lt;div ref=&quot;world&quot; className=&quot;world&quot;&gt;World&lt;/div&gt;</span><br><span class=\"line\">            &lt;/div&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export default HelloWorld;</span><br></pre></td></tr></table></figure></p>\n<p>为了区分ES6语法中的class关键字，当我们在jsx中给元素添加class时，需要使用className来代替<br>我们在jsx中，可以给元素添加ref属性，而这些拥有ref属性的元素，会统一放在组件对象的refs中，因此，当我们想要访问对应的真实DOM时，则通过this.refs来访问即可。<br>当然，ref的值不仅仅可以为一个名字，同时还可以为一个回调函数，这个函数会在render渲染时执行，也就是说，每当render函数执行一次，ref的回调函数也会执行一次。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// src/helloWorld.jsx</span><br><span class=\"line\">import React, &#123; Component &#125; from &apos;react&apos;;class HelloWorld extends Component &#123;</span><br><span class=\"line\">    clickHander = () =&gt; &#123;</span><br><span class=\"line\">        console.log(this.refs)</span><br><span class=\"line\">    &#125; refCallback = (elem) =&gt; &#123;</span><br><span class=\"line\">        console.log(elem);</span><br><span class=\"line\">    &#125; render () &#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;div className=&quot;container&quot; onClick=&#123;this.clickHander&#125;&gt;</span><br><span class=\"line\">                &lt;div ref=&quot;hello&quot; className=&quot;hello&quot;&gt;Hello&lt;/div&gt;</span><br><span class=\"line\">                &lt;div ref=&#123;this.refCallback&#125; className=&quot;world&quot;&gt;World&lt;/div&gt;</span><br><span class=\"line\">            &lt;/div&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;export default HelloWorld;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"组件生命周期\"><a href=\"#组件生命周期\" class=\"headerlink\" title=\"组件生命周期\"></a>组件生命周期</h3><p>件的生命周期，指的就是一个组件，从创建到销毁的这样一个过程，react为组件的生命周期提供了很多的钩子函数</p>\n<h5 id=\"react组件有三种状态：\"><a href=\"#react组件有三种状态：\" class=\"headerlink\" title=\"react组件有三种状态：\"></a>react组件有三种状态：</h5><ul>\n<li>Mounted：已经插入真实DOM</li>\n<li>Updating：正在被重新渲染</li>\n<li>Unmounted：已移出真实DOM</li>\n<li><h5 id=\"每个状态的处理函数\"><a href=\"#每个状态的处理函数\" class=\"headerlink\" title=\"每个状态的处理函数\"></a>每个状态的处理函数</h5></li>\n<li>will：函数在进入状态之前调用</li>\n<li>did：函数在进入状态之后调用</li>\n</ul>\n<h5 id=\"组件第一次渲染完成的前后时刻，所谓的渲染完成，即组件已经被渲染成为真实DOM并插入到了html之中\"><a href=\"#组件第一次渲染完成的前后时刻，所谓的渲染完成，即组件已经被渲染成为真实DOM并插入到了html之中\" class=\"headerlink\" title=\"组件第一次渲染完成的前后时刻，所谓的渲染完成，即组件已经被渲染成为真实DOM并插入到了html之中\"></a>组件第一次渲染完成的前后时刻，所谓的渲染完成，即组件已经被渲染成为真实DOM并插入到了html之中</h5><ul>\n<li>componentWillMount 在首次渲染完成之前，此时可修改组件的state</li>\n<li>componentDidMount 真实DOM渲染完成之后，该方法可通过this.getDOMNode()访问到真实的DOM元素，可以使用其他的类库来操作这个DOM</li>\n</ul>\n<h5 id=\"组件属性-我们前面提到的props与state-更新的前后时刻\"><a href=\"#组件属性-我们前面提到的props与state-更新的前后时刻\" class=\"headerlink\" title=\"组件属性(我们前面提到的props与state)更新的前后时刻\"></a>组件属性(我们前面提到的props与state)更新的前后时刻</h5><ul>\n<li>componentWillUpdate 接收到一个新的state或者props时，在重新render之前调用，此时不允许更新props和state</li>\n<li>componentDidUpdate 组件完成更新之后调用，此时可访问新的DOM元素</li>\n</ul>\n<h6 id=\"组件取消挂载之前-取消之后就没必要提供钩子函数了\"><a href=\"#组件取消挂载之前-取消之后就没必要提供钩子函数了\" class=\"headerlink\" title=\"组件取消挂载之前(取消之后就没必要提供钩子函数了)\"></a>组件取消挂载之前(取消之后就没必要提供钩子函数了)</h6><p><code>componentWillUnmount</code></p>\n<h6 id=\"两个特殊的处理函数\"><a href=\"#两个特殊的处理函数\" class=\"headerlink\" title=\"两个特殊的处理函数\"></a>两个特殊的处理函数</h6><ul>\n<li><code>componentWillReceiveProps(object nextProps)</code>：组件接收到新的props时，在重新render之前调用,此时可以更改props和state。首先props发生改变-&gt;然后componentWillReceiveProps去判断是否需要重新渲染(<code>shouldComponentUpdate</code>)-&gt;如果不需要则继续running-&gt;如果需要则执行<code>componentWillUpdate</code>-&gt;渲染DOM树之后执行<code>componentDidUpdate</code>-&gt;进入running</li>\n<li><code>shouldComponentUpdate(nextProps, nextState)</code>(更新发生前立即被调用) 接收到一个新的state或者props时，在重新render之前调用，组件判断是否重新render前调用。首先state发生改变-&gt;判断是否需要重新渲染新的props和state(<code>shouldComponentUpdate</code>) -&gt; 根据判断决定执行render过程还是继续·保持running状态</li>\n</ul>\n<h6 id=\"三个统一调用的方法-用于组件初始化，获取默认属性和状态\"><a href=\"#三个统一调用的方法-用于组件初始化，获取默认属性和状态\" class=\"headerlink\" title=\"三个统一调用的方法,用于组件初始化，获取默认属性和状态\"></a>三个统一调用的方法,用于组件初始化，获取默认属性和状态</h6><ul>\n<li>getDefaultProps：作用于组件类，只调用一次，返回对象用于设置默认的props，对于引用值，会在实例中共享</li>\n<li>getInitialState：作用于组件的实例，在实例创建时只调用一次，，用于初始化没个实例的state，可访问this.props</li>\n<li>render：必选的方法，创建vistual DOM （1. 只能通过this.props和this.state访问数据 2. 可以返回null、false或任何React组件 3. 只能出现一个顶级组件（不能返回数组）4.不能改变组件的状态 5. 不能修改DOM的输出</li>\n</ul>\n<h6 id=\"已挂载的方法\"><a href=\"#已挂载的方法\" class=\"headerlink\" title=\"已挂载的方法\"></a>已挂载的方法</h6><ul>\n<li>component.forceUpdate() 可以在任何已经挂载的组件上使用，当你知道某些深处的组件状态未通过this.setState而改变了的时候</li>\n</ul>\n<blockquote>\n<p>componentDidMount，组件第一次渲染完成之后调用的componentDidMount，既然是组件第一次渲染完成之后才会调用，也就是说，该函数在react组件的生命周期中，只会调用一次。而渲染完成，则表示组件已经被渲染成为真实DOM插入了html中。所以这时候就可以通过ref获取真实元素。在实际开发中，常常需要通过ajax获取数据，而数据请求的这个行为，则最适合放在componentDidMount中来执行。通常会在首次渲染改变组件状态(state)的行为，或者称之为有副作用的行为，都建议放在componentDidMount中来执行。主要是因为state的改动会引发组件的重新渲染。</p>\n</blockquote>\n<p><img src=\"http://images2017.cnblogs.com/blog/1106982/201708/1106982-20170811224737742-1564011484.jpg\" alt=\"image\"></p>\n<h2 id=\"PropTypes\"><a href=\"#PropTypes\" class=\"headerlink\" title=\"PropTypes\"></a>PropTypes</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import PropTypes from &apos;prop-types&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">MyComponent.propTypes = &#123;</span><br><span class=\"line\">  // You can declare that a prop is a specific JS primitive. By default, these</span><br><span class=\"line\">  // are all optional.</span><br><span class=\"line\">  optionalArray: PropTypes.array,</span><br><span class=\"line\">  optionalBool: PropTypes.bool,</span><br><span class=\"line\">  optionalFunc: PropTypes.func,</span><br><span class=\"line\">  optionalNumber: PropTypes.number,</span><br><span class=\"line\">  optionalObject: PropTypes.object,</span><br><span class=\"line\">  optionalString: PropTypes.string,</span><br><span class=\"line\">  optionalSymbol: PropTypes.symbol,</span><br><span class=\"line\"></span><br><span class=\"line\">  // Anything that can be rendered: numbers, strings, elements or an array</span><br><span class=\"line\">  // (or fragment) containing these types.</span><br><span class=\"line\">  optionalNode: PropTypes.node,</span><br><span class=\"line\"></span><br><span class=\"line\">  // A React element.</span><br><span class=\"line\">  optionalElement: PropTypes.element,</span><br><span class=\"line\"></span><br><span class=\"line\">  // You can also declare that a prop is an instance of a class. This uses</span><br><span class=\"line\">  // JS&apos;s instanceof operator.</span><br><span class=\"line\">  optionalMessage: PropTypes.instanceOf(Message),</span><br><span class=\"line\"></span><br><span class=\"line\">  // You can ensure that your prop is limited to specific values by treating</span><br><span class=\"line\">  // it as an enum.</span><br><span class=\"line\">  optionalEnum: PropTypes.oneOf([&apos;News&apos;, &apos;Photos&apos;]),</span><br><span class=\"line\"></span><br><span class=\"line\">  // An object that could be one of many types</span><br><span class=\"line\">  optionalUnion: PropTypes.oneOfType([</span><br><span class=\"line\">    PropTypes.string,</span><br><span class=\"line\">    PropTypes.number,</span><br><span class=\"line\">    PropTypes.instanceOf(Message)</span><br><span class=\"line\">  ]),</span><br><span class=\"line\"></span><br><span class=\"line\">  // An array of a certain type</span><br><span class=\"line\">  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),</span><br><span class=\"line\"></span><br><span class=\"line\">  // An object with property values of a certain type</span><br><span class=\"line\">  optionalObjectOf: PropTypes.objectOf(PropTypes.number),</span><br><span class=\"line\"></span><br><span class=\"line\">  // An object taking on a particular shape</span><br><span class=\"line\">  optionalObjectWithShape: PropTypes.shape(&#123;</span><br><span class=\"line\">    color: PropTypes.string,</span><br><span class=\"line\">    fontSize: PropTypes.number</span><br><span class=\"line\">  &#125;),</span><br><span class=\"line\"></span><br><span class=\"line\">  // You can chain any of the above with `isRequired` to make sure a warning</span><br><span class=\"line\">  // is shown if the prop isn&apos;t provided.</span><br><span class=\"line\">  requiredFunc: PropTypes.func.isRequired,</span><br><span class=\"line\"></span><br><span class=\"line\">  // A value of any data type</span><br><span class=\"line\">  requiredAny: PropTypes.any.isRequired,</span><br><span class=\"line\"></span><br><span class=\"line\">  // You can also specify a custom validator. It should return an Error</span><br><span class=\"line\">  // object if the validation fails. Don&apos;t `console.warn` or throw, as this</span><br><span class=\"line\">  // won&apos;t work inside `oneOfType`.</span><br><span class=\"line\">  customProp: function(props, propName, componentName) &#123;</span><br><span class=\"line\">    if (!/matchme/.test(props[propName])) &#123;</span><br><span class=\"line\">      return new Error(</span><br><span class=\"line\">        &apos;Invalid prop `&apos; + propName + &apos;` supplied to&apos; +</span><br><span class=\"line\">        &apos; `&apos; + componentName + &apos;`. Validation failed.&apos;</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // You can also supply a custom validator to `arrayOf` and `objectOf`.</span><br><span class=\"line\">  // It should return an Error object if the validation fails. The validator</span><br><span class=\"line\">  // will be called for each key in the array or object. The first two</span><br><span class=\"line\">  // arguments of the validator are the array or object itself, and the</span><br><span class=\"line\">  // current item&apos;s key.</span><br><span class=\"line\">  customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) &#123;</span><br><span class=\"line\">    if (!/matchme/.test(propValue[key])) &#123;</span><br><span class=\"line\">      return new Error(</span><br><span class=\"line\">        &apos;Invalid prop `&apos; + propFullName + &apos;` supplied to&apos; +</span><br><span class=\"line\">        &apos; `&apos; + componentName + &apos;`. Validation failed.&apos;</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjhag1ysu0000i0v67r6wvaud","tag_id":"cjhag1yti0004i0v6p52mki5f","_id":"cjhag1ytr0008i0v6yux2yb9h"},{"post_id":"cjhag1yte0002i0v6wl1yanx3","tag_id":"cjhag1yti0004i0v6p52mki5f","_id":"cjhag1ytu000ai0v6pbhl07pq"},{"post_id":"cjhag1ytl0005i0v6ycevpxci","tag_id":"cjhag1ytt0009i0v6n8q0n7o6","_id":"cjhag1ytw000ci0v6l0gqprgb"},{"post_id":"cjhag1ytn0006i0v6kn7uf0r5","tag_id":"cjhag1ytt0009i0v6n8q0n7o6","_id":"cjhag1ytx000di0v676z34v3y"}],"Tag":[{"name":"哈哈哈1223","_id":"cjhag1yti0004i0v6p52mki5f"},{"name":"react","_id":"cjhag1ytt0009i0v6n8q0n7o6"}]}}